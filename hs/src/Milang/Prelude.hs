{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
module Milang.Prelude (preludeBindings) where

import Milang.Syntax (Binding(..), Expr(..))
import Milang.Parser (parseProgram)
import qualified Data.Text as T

-- | Standard prelude source code
preludeSrc :: T.Text
preludeSrc = T.unlines
  [ "Bool = {True; False}"
  , "List = {Nil; Cons head tail}"
  , "Maybe = {Nothing; Just val}"
  , "Int = Int' 64"
  , "UInt = UInt' 64"
  , "Float = Float' 64"
  , "Byte = UInt' 8"
  -- Trait group aliases (world capability â†’ effect mapping)
  , "console :~ [console]"
  , "io :~ [console]"
  , "fs :~ [fs.read, fs.write]"
  , "process :~ [process]"
  , "env :~ [env]"
  , "if cond #t #e = (truthy cond) -> 0 = $e; _ = $t"
  , "truthy val = val -> False = 0; Nil = 0; Nothing = 0; 0 = 0; \"\" = 0; _ = 1"
  , "toString val = val -> True = \"True\"; False = \"False\"; Nil = \"[]\"; Nothing = \"Nothing\"; Just x = \"Just(\" + toString x + \")\"; _ = _toString val"
  , "fromMaybe default m = m -> Just x = x; Nothing = default"
  , "eq a b = a -> _ = a == b"
  , "id :: a : a"
  , "id x = x"
  , "const :: a : b : a"
  , "const x y = x"
  , "flip :: (a : b : c) : b : a : c"
  , "flip f a b = f b a"
  , "null :: List : Num"
  , "null lst = lst -> Nil = 1; _ = 0"
  , "head :: List : Maybe"
  , "head lst = lst -> Nil = Nothing; Cons h t = Just h"
  , "tail :: List : Maybe"
  , "tail lst = lst -> Nil = Nothing; Cons h t = Just t"
  , "fold :: (a : b : a) : a : List : a"
  , "fold f acc lst = lst -> Nil = acc; Cons h t = fold f (f acc h) t"
  , "map :: (a : b) : List : List"
  , "map f lst = lst -> Nil = []; Cons h t = Cons (f h) (map f t)"
  , "filter :: (a : Num) : List : List"
  , "filter f lst = lst -> Nil = []; Cons h t = if (f h) (Cons h (filter f t)) (filter f t)"
  , "concat :: List : List : List"
  , "concat a b = a -> Nil = b; Cons h t = Cons h (concat t b)"
  , "push :: List : a : List"
  , "push lst x = concat lst [x]"
  , "at :: List : Num : Maybe"
  , "at lst i = lst -> Nil = Nothing; Cons h t = if (i == 0) (Just h) (at t (i - 1))"
  , "at' i lst = at lst i"
  , "sum :: List : Num"
  , "sum lst = fold (\\acc x -> acc + x) 0 lst"
  , "product :: List : Num"
  , "product lst = fold (\\acc x -> acc * x) 1 lst"
  , "any :: (a : Num) : List : Num"
  , "any f lst = fold (\\acc x -> acc || f x) 0 lst"
  , "all :: (a : Num) : List : Num"
  , "all f lst = fold (\\acc x -> acc && f x) 1 lst"
  , "contains :: List : a : Num"
  , "contains lst x = any (\\el -> eq el x) lst"
  , "range :: Num : Num : List"
  , "range start end = range_helper start end []"
  , "range_helper start end acc = if (start >= end) acc (range_helper start (end - 1) (Cons (end - 1) acc))"
  , "zip :: List : List : List"
  , "zip a b = if (null a || null b) [] (Cons [a.head, b.head] (zip a.tail b.tail))"
  , "last :: List : Maybe"
  , "last lst = lst -> Nil = Nothing; Cons h t = if (null t) (Just h) (last t)"
  , "init :: List : Maybe"
  , "init lst = lst -> Nil = Nothing; Cons h t = if (null t) (Just []) (Just (Cons h (fromMaybe [] (init t))))"
  , "reverse :: List : List"
  , "reverse lst = fold (\\acc x -> Cons x acc) [] lst"
  , "take :: Num : List : List"
  , "take n lst = if (n == 0 || null lst) [] (Cons lst.head (take (n - 1) lst.tail))"
  , "drop :: Num : List : List"
  , "drop n lst = if (n == 0) lst (drop (n - 1) lst.tail)"
  , "enumerate :: List : List"
  , "enumerate lst = zip (range 0 (len lst)) lst"
  , "join :: Str : List : Str"
  , "join sep lst = lst -> Nil = \"\"; Cons = if (null lst.tail) lst.head (lst.head + sep + join sep lst.tail)"
  , "abs :: a : a"
  , "abs x = if (x < 0) (0 - x) x"
  , "neg :: Num : Num"
  , "neg x = 0 - x"
  , "min :: a : a : a"
  , "min a b = if (a < b) a b"
  , "max :: a : a : a"
  , "max a b = if (a > b) a b"
  , "not x = if x 0 1"
  -- Operator type signatures (checked by generic annotation machinery)
  , "(+) :: a : a : a"
  , "(-) :: a : a : a"
  , "(*) :: a : a : a"
  , "(/) :: a : a : a"
  , "(%) :: Int : Int : Int"
  , "(**) :: a : Int : a"
  , "(==) :: a : a : Int"
  , "(/=) :: a : a : Int"
  , "(<) :: a : a : Int"
  , "(>) :: a : a : Int"
  , "(<=) :: a : a : Int"
  , "(>=) :: a : a : Int"
  -- Coercion functions
  , "float :: Int : Float"
  , "round :: Float : Int"
  , "floor :: Float : Int"
  , "ceil :: Float : Int"
  , "(<-) base overlay = fold (\\acc pair -> setField acc pair.head pair.tail.head) base (zip (fieldNames overlay) (fields overlay))"
  , "(|>) x f = f x"
  , "(>>) f g x = g (f x)"
  , "(<<) f g x = f (g x)"
  , "(&&) a #b = if a ($b) 0"
  , "(||) a #b = if a 1 ($b)"
  -- Boosted prelude
  , "flatMap f lst = fold (\\acc x -> concat acc (f x)) [] lst"
  , "foldRight f z lst = lst -> Nil = z; Cons h t = f h (foldRight f z t)"
  , "scanLeft f acc lst = Cons acc (scanLeft_tail f acc lst)"
  , "scanLeft_tail f acc lst = lst -> Nil = []; Cons h t = scanLeft f (f acc h) t"
  , "unfold f seed = unfold_step f (f seed)"
  , "unfold_step f result = result -> Nothing = []; Just pair = Cons pair.fst (unfold f pair.snd)"
  , "partition_step pred acc x = if (pred x) (partition_yes acc x) (partition_no acc x)"
  , "partition_yes acc x = {yes = Cons x acc.yes; no = acc.no}"
  , "partition_no acc x = {yes = acc.yes; no = Cons x acc.no}"
  , "partition pred lst = fold (partition_step pred) {yes = []; no = []} lst"
  , "iterate f x = Cons x ~(iterate f (f x))"
  , "curry f a b = f {fst = a; snd = b}"
  , "uncurry f pair = f pair.fst pair.snd"
  , "on f g a b = f (g a) (g b)"
  , "maybe def f m = m -> Nothing = def; Just x = f x"
  , "fst pair = pair.fst"
  , "snd pair = pair.snd"
  , "sortBy cmp lst = lst -> Nil = []; Cons pivot rest = concat (concat (sortBy cmp (filter (\\x -> cmp x pivot < 0) rest)) [pivot]) (sortBy cmp (filter (\\x -> cmp x pivot >= 0) rest))"
  , "sort lst = sortBy (\\a b -> if (a < b) (0 - 1) (if (a == b) 0 1)) lst"
  , "nubBy eq lst = lst -> Nil = []; Cons h t = Cons h (nubBy eq (filter (\\x -> not (eq h x)) t))"
  , "nub lst = nubBy (\\a b -> a == b) lst"
  , "groupBy eq lst = lst -> Nil = []; Cons h t = Cons (Cons h (filter (\\x -> eq h x) t)) (groupBy eq (filter (\\x -> not (eq h x)) t))"
  -- String utilities
  , "startsWith str prefix = slice str 0 (len prefix) == prefix"
  , "endsWith str suffix = slice str (len str - len suffix) (len str) == suffix"
  , "words str = split str \" \""
  , "lines str = split str \"\\n\""
  , "unwords lst = join \" \" lst"
  , "unlines lst = join \"\\n\" lst"
  ]

-- | Parse the prelude source into bindings.
--   Crashes at compile time if the prelude has a syntax error.
preludeBindings :: [Binding]
preludeBindings =
  case parseProgram "<prelude>" preludeSrc of
    Right (Namespace bs) -> bs
    Right _ -> error "prelude: expected namespace"
    Left err -> error $ "prelude parse error: " ++ show err
