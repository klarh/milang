{-# LANGUAGE OverloadedStrings #-}
module Milang.Codegen (codegen) where

import Data.Text (Text)
import qualified Data.Text as T
import Data.IORef
import Data.List (nub, intercalate)
import Milang.Syntax
import System.IO (Handle, hPutStr, hPutStrLn)

-- | Codegen state
data CGState = CGState
  { cgNextId   :: IORef Int
  , cgTopDefs  :: IORef [String]
  , cgIncludes :: IORef [String]
  }

newCGState :: IO CGState
newCGState = CGState <$> newIORef 0 <*> newIORef [] <*> newIORef []

freshId :: CGState -> IO Int
freshId st = do
  n <- readIORef (cgNextId st)
  writeIORef (cgNextId st) (n + 1)
  pure n

addTopDef :: CGState -> String -> IO ()
addTopDef st s = modifyIORef (cgTopDefs st) (s :)

-- | Generate C code from a (partially reduced) Expr
codegen :: Handle -> Expr -> IO ()
codegen h expr = do
  st <- newCGState
  mainCode <- captureIO st expr
  emitPreamble h
  incs <- readIORef (cgIncludes st)
  mapM_ (hPutStrLn h) (nub incs)
  hPutStrLn h ""
  defs <- readIORef (cgTopDefs st)
  mapM_ (hPutStr h) (reverse defs)
  hPutStrLn h ""
  hPutStr h mainCode

-- | Build main()
captureIO :: CGState -> Expr -> IO String
captureIO st expr = do
  ref <- newIORef ""
  let emit s = modifyIORef ref (++ s)
  let emitBuiltins = do
        emit "  mi_env_set(_env, \"print\", mi_native(mi_builtin_print));\n"
        emit "  mi_env_set(_env, \"println\", mi_native(mi_builtin_println));\n"
        emit "  mi_env_set(_env, \"if\", mi_native(mi_builtin_if));\n"
        emit "  mi_env_set(_env, \"len\", mi_native(mi_builtin_len));\n"
        emit "  mi_env_set(_env, \"get\", mi_native(mi_builtin_get));\n"
        emit "  mi_env_set(_env, \"push\", mi_native(mi_builtin_push));\n"
        emit "  mi_env_set(_env, \"concat\", mi_native(mi_builtin_concat));\n"
        emit "  mi_env_set(_env, \"map\", mi_native(mi_builtin_map));\n"
        emit "  mi_env_set(_env, \"fold\", mi_native(mi_builtin_fold));\n"
        emit "  mi_env_set(_env, \"filter\", mi_native(mi_builtin_filter));\n"
        emit "  mi_env_set(_env, \"charAt\", mi_native(mi_builtin_charAt));\n"
        emit "  mi_env_set(_env, \"slice\", mi_native(mi_builtin_slice));\n"
        emit "  mi_env_set(_env, \"indexOf\", mi_native(mi_builtin_indexOf));\n"
        emit "  mi_env_set(_env, \"split\", mi_native(mi_builtin_split));\n"
        emit "  mi_env_set(_env, \"join\", mi_native(mi_builtin_join));\n"
        emit "  mi_env_set(_env, \"trim\", mi_native(mi_builtin_trim));\n"
        emit "  mi_env_set(_env, \"toUpper\", mi_native(mi_builtin_toUpper));\n"
        emit "  mi_env_set(_env, \"toLower\", mi_native(mi_builtin_toLower));\n"
        emit "  mi_env_set(_env, \"replace\", mi_native(mi_builtin_replace));\n"
        emit "  mi_env_set(_env, \"toString\", mi_native(mi_builtin_toString));\n"
        emit "  mi_env_set(_env, \"toInt\", mi_native(mi_builtin_toInt));\n"
        emit "  mi_env_set(_env, \"toFloat\", mi_native(mi_builtin_toFloat));\n"
        emit "  mi_env_set(_env, \"abs\", mi_native(mi_builtin_abs));\n"
        emit "  mi_env_set(_env, \"min\", mi_native(mi_builtin_min));\n"
        emit "  mi_env_set(_env, \"max\", mi_native(mi_builtin_max));\n"
        emit "\n"
  case expr of
    Namespace bs -> do
      let hasMainWithArg = any isMainBinding bs
      emit "int main(int argc, char **argv) {\n"
      emit "  MiEnv *_env = mi_env_new(NULL);\n"
      emitBuiltins
      -- Evaluate each binding in order
      mapM_ (\b -> do
        code <- bindingEvalCode st b
        emit code
        ) bs
      emit "\n"
      if hasMainWithArg
        then do
          -- Application mode: build world, call main(world)
          emit "  MiVal _world = mi_build_world(argc, argv);\n"
          emit "  mi_apply(mi_env_get(_env, \"main\"), _world);\n"
        else do
          -- Script mode: print all bindings
          mapM_ (\b -> do
            let name = T.unpack (bindName b)
            emit $ "  printf(\"" ++ name ++ " = \"); mi_print_val(mi_env_get(_env, \"" ++ name ++ "\")); printf(\"\\n\");\n"
            ) bs
      emit "  return 0;\n}\n"
    _ -> do
      emit "int main(int argc, char **argv) {\n"
      emit "  (void)argc; (void)argv;\n"
      emit "  MiEnv *_env = mi_env_new(NULL);\n"
      emitBuiltins
      code <- exprToC st expr
      emit $ "  mi_print_val(mi_eval(" ++ code ++ ", _env)); printf(\"\\n\");\n"
      emit "  return 0;\n}\n"
  readIORef ref

-- | Detect a `main` binding that takes at least one parameter.
-- After reduction, `main x = ...` becomes `main = \x -> ...`
isMainBinding :: Binding -> Bool
isMainBinding b = bindName b == "main" &&
  (not (null (bindParams b)) || isLam (bindBody b))
  where
    isLam (Lam _ _) = True
    isLam _         = False

-- | Generate code to evaluate a binding and add it to _env
bindingEvalCode :: CGState -> Binding -> IO String
bindingEvalCode st b = do
  let name = T.unpack (bindName b)
  bodyExpr <- if null (bindParams b)
    then pure (bindBody b)
    else pure $ foldr Lam (bindBody b) (bindParams b)
  code0 <- exprToC st bodyExpr
  let code = withLoc (bindPos b) code0
  if bindLazy b
    then pure $ "  { MiExpr *_thunk_body = " ++ code ++ ";\n" ++
                "    MiVal _thunk; _thunk.type = MI_CLOSURE;\n" ++
                "    _thunk.as.closure.body = _thunk_body;\n" ++
                "    _thunk.as.closure.param = \"_thunk_\";\n" ++
                "    _thunk.as.closure.env = _env;\n" ++
                "    mi_env_set(_env, \"" ++ name ++ "\", _thunk); }\n"
    else pure $ "  mi_env_set(_env, \"" ++ name ++ "\", mi_eval(" ++ code ++ ", _env));\n"

-- ── Expression → MiExpr* construction ─────────────────────────────

-- | Wrap a C expression with source location
withLoc :: Maybe SrcPos -> String -> String
withLoc Nothing c = c
withLoc (Just pos) c = "mi_expr_loc(" ++ c ++ ", \"" ++ cEscLoc pos ++ "\")"

cEscLoc :: SrcPos -> String
cEscLoc (SrcPos f l c) = concatMap escChar f ++ ":" ++ show l ++ ":" ++ show c
  where
    escChar '\\' = "\\\\"
    escChar '"'  = "\\\""
    escChar ch   = [ch]

exprToC :: CGState -> Expr -> IO String
exprToC _ (IntLit n) = pure $ "mi_expr_int(" ++ show n ++ ")"
exprToC _ (FloatLit d) = pure $ "mi_expr_float(" ++ show d ++ ")"
exprToC _ (StringLit s) = pure $ "mi_expr_string(" ++ cStringLit (T.unpack s) ++ ")"
exprToC _ (Name n) = pure $ "mi_expr_name(\"" ++ T.unpack n ++ "\")"

exprToC st (BinOp op l r) = do
  lc <- exprToC st l
  rc <- exprToC st r
  pure $ "mi_expr_binop(\"" ++ T.unpack op ++ "\", " ++ lc ++ ", " ++ rc ++ ")"

exprToC st (App f x) = do
  fc <- exprToC st f
  xc <- exprToC st x
  pure $ "mi_expr_app(" ++ fc ++ ", " ++ xc ++ ")"

exprToC st (Lam param body) = do
  bc <- exprToC st body
  pure $ "mi_expr_lam(\"" ++ T.unpack param ++ "\", " ++ bc ++ ")"

exprToC st (With body bindings) = do
  bc <- exprToC st body
  bindCodes <- mapM (bindingStructToC st) bindings
  pure $ "mi_expr_with(" ++ bc ++ ", " ++ show (length bindings) ++ ", " ++
    intercalate ", " bindCodes ++ ")"

exprToC st (Record tag bindings) = do
  bindCodes <- mapM (bindingStructToC st) bindings
  pure $ "mi_expr_record(\"" ++ T.unpack tag ++ "\", " ++ show (length bindings) ++
    (if null bindCodes then "" else ", " ++ intercalate ", " bindCodes) ++ ")"

exprToC st (FieldAccess e field) = do
  ec <- exprToC st e
  pure $ "mi_expr_field(" ++ ec ++ ", \"" ++ T.unpack field ++ "\")"

exprToC st (Namespace bindings) = do
  bindCodes <- mapM (bindingStructToC st) bindings
  let args = if null bindCodes then "" else ", " ++ intercalate ", " bindCodes
  pure $ "mi_expr_namespace(" ++ show (length bindings) ++ args ++ ")"

exprToC st (Case scrut alts) = do
  sc <- exprToC st scrut
  altCodes <- mapM (altToC st) alts
  pure $ "mi_expr_case(" ++ sc ++ ", " ++ show (length alts) ++ ", " ++
    intercalate ", " altCodes ++ ")"

exprToC st (Thunk body) = do
  bc <- exprToC st body
  pure $ "mi_expr_thunk(" ++ bc ++ ")"

exprToC st (ListLit es) = do
  elemCodes <- mapM (exprToC st) es
  pure $ "mi_expr_list(" ++ show (length es) ++
    (if null es then "" else ", " ++ intercalate ", " elemCodes) ++ ")"

exprToC st (RecordUpdate base updates) = do
  baseCode <- exprToC st base
  updateCodes <- mapM (bindingStructToC st) updates
  let n = length updates
  pure $ "mi_expr_record_update(" ++ baseCode ++ ", " ++ show n ++
    ", (MiBinding[]){" ++ intercalate ", " updateCodes ++ "})"

exprToC st (CFunction hdr cname retTy paramTys) = do
  modifyIORef (cgIncludes st) (("#include " ++ show (T.unpack hdr)) :)
  nativeCode <- cfunctionToC st (T.unpack cname) retTy paramTys
  pure $ "mi_expr_val(" ++ nativeCode ++ ")"

-- | Escape a string for C
cStringLit :: String -> String
cStringLit s = "\"" ++ concatMap esc s ++ "\""
  where
    esc '"'  = "\\\""
    esc '\\' = "\\\\"
    esc '\n' = "\\n"
    esc '\t' = "\\t"
    esc c    = [c]

-- | Convert a Binding to C MiBinding struct
bindingStructToC :: CGState -> Binding -> IO String
bindingStructToC st b = do
  bc <- exprToC st (bindBody b)
  let bc' = withLoc (bindPos b) bc
  let lazyFlag = if bindLazy b then "1" else "0"
  pure $ "mi_binding(\"" ++ T.unpack (bindName b) ++ "\", " ++ lazyFlag ++ ", " ++
    show (length (bindParams b)) ++
    concatMap (\p -> ", \"" ++ T.unpack p ++ "\"") (bindParams b) ++
    ", " ++ bc' ++ ")"

-- | Convert an Alt to C MiAlt struct
altToC :: CGState -> Alt -> IO String
altToC st (Alt pat body) = do
  pc <- patToC pat
  bc <- exprToC st body
  pure $ "mi_alt(" ++ pc ++ ", " ++ bc ++ ")"

-- | Convert a Pat to C MiPat
patToC :: Pat -> IO String
patToC (PVar v) = pure $ "mi_pat_var(\"" ++ T.unpack v ++ "\")"
patToC PWild = pure "mi_pat_wild()"
patToC (PLit (IntLit n)) = pure $ "mi_pat_int(" ++ show n ++ ")"
patToC (PLit (StringLit s)) = pure $ "mi_pat_string(" ++ cStringLit (T.unpack s) ++ ")"
patToC (PLit _) = pure "mi_pat_wild()"
patToC (PRec tag fields) = do
  fieldCodes <- mapM (\(f, p) -> do
    pc <- patToC p
    pure $ "\"" ++ T.unpack f ++ "\", " ++ pc
    ) fields
  pure $ "mi_pat_rec(\"" ++ T.unpack tag ++ "\", " ++ show (length fields) ++
    (if null fields then "" else ", " ++ intercalate ", " fieldCodes) ++ ")"
patToC (PList pats mrest) = do
  patCodes <- mapM patToC pats
  let restCode = case mrest of
        Nothing -> "NULL"
        Just name -> "\"" ++ T.unpack name ++ "\""
  pure $ "mi_pat_list(" ++ show (length pats) ++ ", " ++ restCode ++
    (if null pats then "" else ", " ++ intercalate ", " patCodes) ++ ")"

-- ── C FFI codegen (native closures) ──────────────────────────────

cfunctionToC :: CGState -> String -> CType -> [CType] -> IO String
cfunctionToC st cname retTy allParamTys = do
  let indexed = zip [0::Int ..] allParamTys
      inputParams  = [(i, t) | (i, t) <- indexed, not (isOutputParam t)]
      outputParams = [(i, t) | (i, t) <- indexed, isOutputParam t]
      nInputs = length inputParams
  case nInputs of
    0 -> cffiLeaf st cname retTy allParamTys inputParams outputParams
    _ -> cffiCurried st cname retTy allParamTys inputParams outputParams

cffiLeaf :: CGState -> String -> CType -> [CType]
         -> [(Int, CType)] -> [(Int, CType)] -> IO String
cffiLeaf st cname retTy allParamTys inputParams outputParams = do
  cid <- freshId st
  let fnName = "mi_cffi_" ++ show cid
      nInputs = length inputParams
      hasOuts = not (null outputParams)
      envFields
        | nInputs <= 1 = ""
        | otherwise = concatMap (\k ->
            "  MiVal _a" ++ show k ++ ";\n") [0..nInputs-2]
      envStruct
        | nInputs <= 1 = ""
        | otherwise = "struct " ++ fnName ++ "_env {\n" ++ envFields ++ "};\n\n"
      envCast
        | nInputs <= 1 = ""
        | otherwise = "  struct " ++ fnName ++ "_env *_e = (struct " ++ fnName ++ "_env *)_env;\n"
      envUnpack
        | nInputs <= 1 = ""
        | otherwise = concatMap (\k ->
            "  MiVal _a" ++ show k ++ " = _e->_a" ++ show k ++ ";\n") [0..nInputs-2]
      inputArgExpr k
        | nInputs == 0 = error "no inputs"
        | nInputs == 1 = "_arg"
        | k == nInputs - 1 = "_arg"
        | otherwise = "_a" ++ show k
      outDecls = concatMap (\(i, t) ->
        let cty = case t of COutInt -> "int"; COutFloat -> "double"; _ -> "int"
        in "  " ++ cty ++ " _out_" ++ show i ++ " = 0;\n") outputParams
      cArgList = intercalate ", " $ map (\(origIdx, t) ->
        if isOutputParam t
          then "&_out_" ++ show origIdx
          else let inputIdx = length [() | (j, _) <- inputParams, j < origIdx]
               in miToCArg t (inputArgExpr inputIdx)
        ) (zip [0..] allParamTys)
      callExpr = cname ++ "(" ++ cArgList ++ ")"
      returnExpr
        | not hasOuts = cRetToMi retTy callExpr
        | retTy == CVoid =
            "(" ++ callExpr ++ ",\n" ++ buildOutRecord outputParams ++ ")"
        | otherwise =
            "({ " ++ cRetTypeName retTy ++ " _ret = " ++ callExpr ++ ";\n" ++
            buildOutRecordWithRet retTy outputParams ++ " })"
      fnDef = envStruct ++
              "static MiVal " ++ fnName ++ "(MiVal _arg, void *_env) {\n" ++
              (if nInputs == 0 then "  (void)_arg; " else "") ++
              (if nInputs <= 1 then "  (void)_env;\n" else "") ++
              envCast ++ envUnpack ++ outDecls ++
              "  return " ++ returnExpr ++ ";\n}\n\n"
  addTopDef st fnDef
  pure $ "mi_native(" ++ fnName ++ ")"

buildOutRecord :: [(Int, CType)] -> String
buildOutRecord outs =
  let n = length outs
      fields = concatMap (\(idx, (i, t)) ->
        let val = outToMi t ("_out_" ++ show i)
        in "    _fields[" ++ show idx ++ "] = " ++ val ++ ";\n") (zip [0..] outs)
      names = concatMap (\(i, _) -> "\"out" ++ show i ++ "\", ") outs
  in "({\n    MiVal *_fields = malloc(" ++ show n ++ " * sizeof(MiVal));\n" ++
     "    static const char *_names[] = {" ++ names ++ "};\n" ++ fields ++
     "    MiVal _r; _r.type = MI_RECORD; _r.as.rec.tag = \"Result\";" ++
     " _r.as.rec.names = _names; _r.as.rec.fields = _fields;" ++
     " _r.as.rec.nfields = " ++ show n ++ "; _r;\n  })"

buildOutRecordWithRet :: CType -> [(Int, CType)] -> String
buildOutRecordWithRet retTy outs =
  let n = 1 + length outs
      retField = "    _fields[0] = " ++ cRetToMi retTy "_ret" ++ ";\n"
      outFields = concatMap (\(idx, (i, t)) ->
        let val = outToMi t ("_out_" ++ show (i :: Int))
        in "    _fields[" ++ show ((idx :: Int) + 1) ++ "] = " ++ val ++ ";\n")
        (zip [0..] outs)
      names = "\"value\", " ++ concatMap (\(i, _) -> "\"out" ++ show i ++ "\", ") outs
  in "MiVal *_fields = malloc(" ++ show n ++ " * sizeof(MiVal));\n" ++
     "  static const char *_names[] = {" ++ names ++ "};\n" ++
     retField ++ outFields ++
     "  MiVal _r; _r.type = MI_RECORD; _r.as.rec.tag = \"Result\";" ++
     " _r.as.rec.names = _names; _r.as.rec.fields = _fields;" ++
     " _r.as.rec.nfields = " ++ show n ++ "; _r;"

outToMi :: CType -> String -> String
outToMi COutInt name   = "mi_int((int64_t)" ++ name ++ ")"
outToMi COutFloat name = "mi_float((double)" ++ name ++ ")"
outToMi t name         = cRetToMi t name

cRetTypeName :: CType -> String
cRetTypeName CInt    = "int64_t"
cRetTypeName CFloat  = "double"
cRetTypeName CString = "char *"
cRetTypeName CPtr    = "void *"
cRetTypeName CVoid   = "void"
cRetTypeName COutInt = "int"
cRetTypeName COutFloat = "double"

cffiCurried :: CGState -> String -> CType -> [CType]
            -> [(Int, CType)] -> [(Int, CType)] -> IO String
cffiCurried st cname retTy allParamTys inputParams outputParams = do
  let nInputs = length inputParams
  leafCode <- cffiLeaf st cname retTy allParamTys inputParams outputParams
  if nInputs == 1
    then pure leafCode
    else do
      leafFnName <- do
        n <- readIORef (cgNextId st)
        pure $ "mi_cffi_" ++ show (n - 1)
      ids <- mapM (\_ -> freshId st) [0..nInputs-2]
      let wrapperNames = map (\i -> "mi_cffi_" ++ show i) ids
      mapM_ (\k -> do
        let fnName = wrapperNames !! k
            envName = fnName ++ "_env"
            nextName = if k == nInputs - 2 then leafFnName else wrapperNames !! (k + 1)
            nextEnvName = nextName ++ "_env"
        if k == 0
          then do
            let fnDef = "static MiVal " ++ fnName ++ "(MiVal _arg, void *_env) {\n" ++
                        "  (void)_env;\n" ++
                        "  struct " ++ nextEnvName ++ " *_ne = malloc(sizeof(struct " ++ nextEnvName ++ "));\n" ++
                        "  _ne->_a0 = _arg;\n" ++
                        "  return mi_native_env(" ++ nextName ++ ", _ne);\n}\n\n"
            addTopDef st fnDef
          else do
            let envFields = concatMap (\i -> "  MiVal _a" ++ show i ++ ";\n") [0..k-1]
                envStruct = "struct " ++ envName ++ " {\n" ++ envFields ++ "};\n\n"
                envCast = "  struct " ++ envName ++ " *_e = (struct " ++ envName ++ " *)_env;\n"
                allocNext = "  struct " ++ nextEnvName ++ " *_ne = malloc(sizeof(struct " ++ nextEnvName ++ "));\n" ++
                            concatMap (\i -> "  _ne->_a" ++ show i ++ " = _e->_a" ++ show i ++ ";\n") [0..k-1] ++
                            "  _ne->_a" ++ show k ++ " = _arg;\n"
                fnDef = envStruct ++
                        "static MiVal " ++ fnName ++ "(MiVal _arg, void *_env) {\n" ++
                        envCast ++ allocNext ++
                        "  return mi_native_env(" ++ nextName ++ ", _ne);\n}\n\n"
            addTopDef st fnDef
        ) (reverse [0..nInputs-2])
      pure $ "mi_native(" ++ wrapperNames !! 0 ++ ")"

cRetToMi :: CType -> String -> String
cRetToMi CInt expr     = "mi_int((int64_t)(" ++ expr ++ "))"
cRetToMi CFloat expr   = "mi_float((double)(" ++ expr ++ "))"
cRetToMi CString expr  = "mi_string(" ++ expr ++ ")"
cRetToMi CVoid expr    = "(" ++ expr ++ ", mi_int(0))"
cRetToMi CPtr expr     = "mi_pointer((void*)(" ++ expr ++ "))"
cRetToMi COutInt _     = "mi_int(0)"
cRetToMi COutFloat _   = "mi_float(0)"

miToCArg :: CType -> String -> String
miToCArg CInt name     = "(int)(" ++ name ++ ".as.i)"
miToCArg CFloat name   = "mi_to_float(" ++ name ++ ")"
miToCArg CString name  = name ++ ".as.str.data"
miToCArg CVoid _       = "/* void */"
miToCArg CPtr name     = name ++ ".as.ptr"
miToCArg COutInt name  = "&_out_" ++ name
miToCArg COutFloat name = "&_out_" ++ name

isOutputParam :: CType -> Bool
isOutputParam COutInt   = True
isOutputParam COutFloat = True
isOutputParam _         = False

-- ── C runtime preamble ────────────────────────────────────────────

emitPreamble :: Handle -> IO ()
emitPreamble h = hPutStr h $ unlines
  [ "#define _GNU_SOURCE"
  , "#include <stdio.h>"
  , "#include <stdlib.h>"
  , "#include <string.h>"
  , "#include <stdint.h>"
  , "#include <math.h>"
  , "#include <stdarg.h>"
  , "#include <ctype.h>"
  , ""
  , "// ── Forward declarations ──"
  , "typedef struct MiVal MiVal;"
  , "typedef struct MiExpr MiExpr;"
  , "typedef struct MiEnv MiEnv;"
  , "typedef struct MiBinding MiBinding;"
  , "typedef struct MiAlt MiAlt;"
  , "typedef struct MiPat MiPat;"
  , ""
  , "// ── MiVal: runtime values ──"
  , "typedef enum { MI_INT, MI_FLOAT, MI_STRING, MI_RECORD, MI_CLOSURE, MI_NATIVE, MI_POINTER, MI_LIST } MiType;"
  , ""
  , "struct MiVal {"
  , "  MiType type;"
  , "  union {"
  , "    int64_t i;"
  , "    double f;"
  , "    struct { char *data; int len; } str;"
  , "    struct { const char *tag; const char **names; MiVal *fields; int nfields; } rec;"
  , "    struct { MiExpr *body; const char *param; MiEnv *env; } closure;"
  , "    struct { MiVal (*fn)(MiVal, void*); void *env; } native;"
  , "    void *ptr;"
  , "    struct { MiVal *items; int len; int cap; } list;"
  , "  } as;"
  , "};"
  , ""
  , "// ── MiExpr: expression tree ──"
  , "typedef enum {"
  , "  EXPR_INT, EXPR_FLOAT, EXPR_STRING, EXPR_NAME, EXPR_BINOP, EXPR_APP,"
  , "  EXPR_LAM, EXPR_WITH, EXPR_RECORD, EXPR_FIELD, EXPR_NAMESPACE,"
  , "  EXPR_CASE, EXPR_THUNK, EXPR_LIST, EXPR_VAL, EXPR_RECORD_UPDATE"
  , "} ExprType;"
  , ""
  , "struct MiExpr {"
  , "  ExprType type;"
  , "  const char *loc;  // source location for error reporting (may be NULL)"
  , "  union {"
  , "    int64_t i;"
  , "    double f;"
  , "    char *s;"
  , "    char *name;"
  , "    struct { char *op; MiExpr *left; MiExpr *right; } binop;"
  , "    struct { MiExpr *fn; MiExpr *arg; } app;"
  , "    struct { char *param; MiExpr *body; } lam;"
  , "    struct { MiExpr *body; int nbindings; MiBinding *bindings; } with;"
  , "    struct { char *tag; int nbindings; MiBinding *bindings; } record;"
  , "    struct { MiExpr *expr; char *field; } field;"
  , "    struct { int nbindings; MiBinding *bindings; } ns;"
  , "    struct { MiExpr *scrut; int nalts; MiAlt *alts; } cas;"
  , "    struct { MiExpr *body; } thunk;"
  , "    struct { int len; MiExpr **items; } list;"
  , "    struct { MiExpr *base; int nupdates; MiBinding *updates; } rupd;"
  , "    MiVal val;"
  , "  } as;"
  , "};"
  , ""
  , "struct MiBinding {"
  , "  char *name;"
  , "  int lazy;"
  , "  int nparams;"
  , "  char **params;"
  , "  MiExpr *body;"
  , "};"
  , ""
  , "// ── MiPat ──"
  , "typedef enum { PAT_VAR, PAT_WILD, PAT_INT, PAT_STRING, PAT_REC, PAT_LIST } PatType;"
  , ""
  , "struct MiPat {"
  , "  PatType type;"
  , "  union {"
  , "    char *var;"
  , "    int64_t i;"
  , "    char *s;"
  , "    struct { char *tag; int nfields; char **field_names; MiPat **field_pats; } rec;"
  , "    struct { int npats; MiPat **pats; char *rest; } list;"
  , "  } as;"
  , "};"
  , ""
  , "struct MiAlt {"
  , "  MiPat *pat;"
  , "  MiExpr *body;"
  , "};"
  , ""
  , "// ── MiEnv ──"
  , "struct MiEnv {"
  , "  char *name;"
  , "  MiVal val;"
  , "  MiEnv *next;"
  , "  MiEnv *parent;"
  , "};"
  , ""
  , "// ── Value constructors ──"
  , "static MiVal mi_int(int64_t v) { MiVal r; r.type = MI_INT; r.as.i = v; return r; }"
  , "static MiVal mi_float(double v) { MiVal r; r.type = MI_FLOAT; r.as.f = v; return r; }"
  , "static MiVal mi_string(const char *s) { MiVal r; r.type = MI_STRING; int n = strlen(s); r.as.str.data = malloc(n+1); memcpy(r.as.str.data, s, n+1); r.as.str.len = n; return r; }"
  , "static MiVal mi_stringn(const char *s, int n) { MiVal r; r.type = MI_STRING; r.as.str.data = malloc(n+1); memcpy(r.as.str.data, s, n); r.as.str.data[n] = '\\0'; r.as.str.len = n; return r; }"
  , "static MiVal mi_pointer(void *p) { MiVal r; r.type = MI_POINTER; r.as.ptr = p; return r; }"
  , "static MiVal mi_list(MiVal *items, int len) {"
  , "  MiVal r; r.type = MI_LIST; r.as.list.items = items; r.as.list.len = len; r.as.list.cap = len; return r;"
  , "}"
  , "static MiVal mi_native(MiVal (*fn)(MiVal, void*)) {"
  , "  MiVal r; r.type = MI_NATIVE; r.as.native.fn = fn; r.as.native.env = NULL; return r;"
  , "}"
  , "static MiVal mi_native_env(MiVal (*fn)(MiVal, void*), void *env) {"
  , "  MiVal r; r.type = MI_NATIVE; r.as.native.fn = fn; r.as.native.env = env; return r;"
  , "}"
  , ""
  , "// ── Error helpers ──"
  , "static void mi_error(const char *loc, const char *msg) {"
  , "  if (loc) fprintf(stderr, \"%s: %s\\n\", loc, msg);"
  , "  else fprintf(stderr, \"%s\\n\", msg);"
  , "  exit(1);"
  , "}"
  , "static void mi_errorf(const char *loc, const char *fmt, ...) {"
  , "  if (loc) fprintf(stderr, \"%s: \", loc);"
  , "  va_list args; va_start(args, fmt);"
  , "  vfprintf(stderr, fmt, args); va_end(args);"
  , "  fprintf(stderr, \"\\n\"); exit(1);"
  , "}"
  , ""
  , "// ── Env operations ──"
  , "static MiEnv *mi_env_new(MiEnv *parent) {"
  , "  MiEnv *e = calloc(1, sizeof(MiEnv)); e->parent = parent; return e;"
  , "}"
  , ""
  , "static void mi_env_set(MiEnv *env, const char *name, MiVal val) {"
  , "  MiEnv *entry = malloc(sizeof(MiEnv));"
  , "  entry->name = strdup(name); entry->val = val;"
  , "  entry->next = env->next; entry->parent = NULL;"
  , "  env->next = entry;"
  , "}"
  , ""
  , "static MiVal mi_env_get_loc(MiEnv *env, const char *name, const char *loc) {"
  , "  MiEnv *frame = env;"
  , "  while (frame) {"
  , "    for (MiEnv *e = frame; e; e = e->next)"
  , "      if (e->name && strcmp(e->name, name) == 0) return e->val;"
  , "    frame = frame->parent;"
  , "  }"
  , "  // Uppercase unbound names are zero-field constructors (e.g., None)"
  , "  if (name[0] >= 'A' && name[0] <= 'Z') {"
  , "    MiVal r; r.type = MI_RECORD; r.as.rec.tag = name;"
  , "    r.as.rec.nfields = 0; r.as.rec.names = NULL; r.as.rec.fields = NULL;"
  , "    return r;"
  , "  }"
  , "  mi_errorf(loc, \"unbound variable: %s\", name);"
  , "  exit(1); // unreachable"
  , "}"
  , "static MiVal mi_env_get(MiEnv *env, const char *name) { return mi_env_get_loc(env, name, NULL); }"
  , ""
  , "// ── Expr constructors ──"
  , "static MiExpr *mi_expr_int(int64_t v) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_INT; e->as.i = v; return e;"
  , "}"
  , "static MiExpr *mi_expr_float(double v) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_FLOAT; e->as.f = v; return e;"
  , "}"
  , "static MiExpr *mi_expr_string(const char *s) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_STRING; e->as.s = strdup(s); return e;"
  , "}"
  , "static MiExpr *mi_expr_name(const char *n) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_NAME; e->as.name = strdup(n); return e;"
  , "}"
  , "static MiExpr *mi_expr_binop(const char *op, MiExpr *l, MiExpr *r) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_BINOP;"
  , "  e->as.binop.op = strdup(op); e->as.binop.left = l; e->as.binop.right = r; return e;"
  , "}"
  , "static MiExpr *mi_expr_app(MiExpr *fn, MiExpr *arg) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_APP;"
  , "  e->as.app.fn = fn; e->as.app.arg = arg; return e;"
  , "}"
  , "static MiExpr *mi_expr_lam(const char *param, MiExpr *body) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_LAM;"
  , "  e->as.lam.param = strdup(param); e->as.lam.body = body; return e;"
  , "}"
  , "static MiExpr *mi_expr_val(MiVal v) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_VAL; e->as.val = v; return e;"
  , "}"
  , "static MiExpr *mi_expr_field(MiExpr *expr, const char *field) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_FIELD;"
  , "  e->as.field.expr = expr; e->as.field.field = strdup(field); return e;"
  , "}"
  , "static MiExpr *mi_expr_thunk(MiExpr *body) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_THUNK; e->as.thunk.body = body; return e;"
  , "}"
  , ""
  , "static MiBinding mi_binding(const char *name, int lazy, int nparams, ...) {"
  , "  MiBinding b; b.name = strdup(name); b.lazy = lazy; b.nparams = nparams;"
  , "  va_list args; va_start(args, nparams);"
  , "  if (nparams > 0) {"
  , "    b.params = malloc(nparams * sizeof(char*));"
  , "    for (int i = 0; i < nparams; i++) b.params[i] = strdup(va_arg(args, char*));"
  , "  } else { b.params = NULL; }"
  , "  b.body = va_arg(args, MiExpr*); va_end(args); return b;"
  , "}"
  , ""
  , "static MiExpr *mi_expr_with(MiExpr *body, int n, ...) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_WITH;"
  , "  e->as.with.body = body; e->as.with.nbindings = n;"
  , "  e->as.with.bindings = malloc(n * sizeof(MiBinding));"
  , "  va_list args; va_start(args, n);"
  , "  for (int i = 0; i < n; i++) e->as.with.bindings[i] = va_arg(args, MiBinding);"
  , "  va_end(args); return e;"
  , "}"
  , ""
  , "static MiExpr *mi_expr_record(const char *tag, int n, ...) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_RECORD;"
  , "  e->as.record.tag = strdup(tag); e->as.record.nbindings = n;"
  , "  e->as.record.bindings = malloc(n * sizeof(MiBinding));"
  , "  va_list args; va_start(args, n);"
  , "  for (int i = 0; i < n; i++) e->as.record.bindings[i] = va_arg(args, MiBinding);"
  , "  va_end(args); return e;"
  , "}"
  , ""
  , "static MiExpr *mi_expr_namespace(int n, ...) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_NAMESPACE;"
  , "  e->as.ns.nbindings = n; e->as.ns.bindings = malloc(n * sizeof(MiBinding));"
  , "  va_list args; va_start(args, n);"
  , "  for (int i = 0; i < n; i++) e->as.ns.bindings[i] = va_arg(args, MiBinding);"
  , "  va_end(args); return e;"
  , "}"
  , ""
  , "static MiExpr *mi_expr_list(int n, ...) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_LIST;"
  , "  e->as.list.len = n; e->as.list.items = malloc(n * sizeof(MiExpr*));"
  , "  va_list args; va_start(args, n);"
  , "  for (int i = 0; i < n; i++) e->as.list.items[i] = va_arg(args, MiExpr*);"
  , "  va_end(args); return e;"
  , "}"
  , ""
  , "static MiExpr *mi_expr_record_update(MiExpr *base, int n, MiBinding *updates) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_RECORD_UPDATE;"
  , "  e->as.rupd.base = base; e->as.rupd.nupdates = n; e->as.rupd.updates = updates;"
  , "  return e;"
  , "}"
  , ""
  , "// Set source location on an expression node"
  , "static MiExpr *mi_expr_loc(MiExpr *e, const char *loc) { e->loc = loc; return e; }"
  , ""
  , "// ── Pat constructors ──"
  , "static MiPat *mi_pat_var(const char *v) {"
  , "  MiPat *p = malloc(sizeof(MiPat)); p->type = PAT_VAR; p->as.var = strdup(v); return p;"
  , "}"
  , "static MiPat *mi_pat_wild(void) { MiPat *p = malloc(sizeof(MiPat)); p->type = PAT_WILD; return p; }"
  , "static MiPat *mi_pat_int(int64_t v) {"
  , "  MiPat *p = malloc(sizeof(MiPat)); p->type = PAT_INT; p->as.i = v; return p;"
  , "}"
  , "static MiPat *mi_pat_string(const char *s) {"
  , "  MiPat *p = malloc(sizeof(MiPat)); p->type = PAT_STRING; p->as.s = strdup(s); return p;"
  , "}"
  , "static MiPat *mi_pat_rec(const char *tag, int n, ...) {"
  , "  MiPat *p = malloc(sizeof(MiPat)); p->type = PAT_REC;"
  , "  p->as.rec.tag = strdup(tag); p->as.rec.nfields = n;"
  , "  p->as.rec.field_names = malloc(n * sizeof(char*));"
  , "  p->as.rec.field_pats = malloc(n * sizeof(MiPat*));"
  , "  va_list args; va_start(args, n);"
  , "  for (int i = 0; i < n; i++) {"
  , "    p->as.rec.field_names[i] = strdup(va_arg(args, char*));"
  , "    p->as.rec.field_pats[i] = va_arg(args, MiPat*);"
  , "  }"
  , "  va_end(args); return p;"
  , "}"
  , "static MiPat *mi_pat_list(int n, char *rest, ...) {"
  , "  MiPat *p = malloc(sizeof(MiPat)); p->type = PAT_LIST;"
  , "  p->as.list.npats = n; p->as.list.rest = rest ? strdup(rest) : NULL;"
  , "  p->as.list.pats = malloc(n * sizeof(MiPat*));"
  , "  va_list args; va_start(args, rest);"
  , "  for (int i = 0; i < n; i++) p->as.list.pats[i] = va_arg(args, MiPat*);"
  , "  va_end(args); return p;"
  , "}"
  , ""
  , "static MiAlt mi_alt(MiPat *pat, MiExpr *body) { MiAlt a; a.pat = pat; a.body = body; return a; }"
  , ""
  , "static MiExpr *mi_expr_case(MiExpr *scrut, int n, ...) {"
  , "  MiExpr *e = calloc(1, sizeof(MiExpr)); e->type = EXPR_CASE;"
  , "  e->as.cas.scrut = scrut; e->as.cas.nalts = n;"
  , "  e->as.cas.alts = malloc(n * sizeof(MiAlt));"
  , "  va_list args; va_start(args, n);"
  , "  for (int i = 0; i < n; i++) e->as.cas.alts[i] = va_arg(args, MiAlt);"
  , "  va_end(args); return e;"
  , "}"
  , ""
  , "// ── Helpers ──"
  , "static double mi_to_float(MiVal v) {"
  , "  return v.type == MI_FLOAT ? v.as.f : (double)v.as.i;"
  , "}"
  , ""
  , "static MiVal mi_field_loc(MiVal rec, const char *name, const char *loc) {"
  , "  if (rec.type != MI_RECORD) { mi_error(loc, \"field access on non-record\"); }"
  , "  for (int i = 0; i < rec.as.rec.nfields; i++)"
  , "    if (rec.as.rec.names && strcmp(rec.as.rec.names[i], name) == 0)"
  , "      return rec.as.rec.fields[i];"
  , "  mi_errorf(loc, \"field '%s' not found in record '%s'\", name, rec.as.rec.tag);"
  , "  exit(1); // unreachable"
  , "}"
  , "static MiVal mi_field(MiVal rec, const char *name) { return mi_field_loc(rec, name, NULL); }"
  , ""
  , "static MiVal mi_apply(MiVal f, MiVal arg);"
  , "static MiVal mi_eval(MiExpr *expr, MiEnv *env);"
  , ""
  , "// ── Printing ──"
  , "static void mi_print_val(MiVal v) {"
  , "  switch (v.type) {"
  , "    case MI_INT:    printf(\"%ld\", v.as.i); break;"
  , "    case MI_FLOAT:  printf(\"%g\", v.as.f); break;"
  , "    case MI_STRING: printf(\"%.*s\", v.as.str.len, v.as.str.data); break;"
  , "    case MI_RECORD:"
  , "      printf(\"%s {\", v.as.rec.tag);"
  , "      for (int i = 0; i < v.as.rec.nfields; i++) {"
  , "        if (i > 0) printf(\", \");"
  , "        if (v.as.rec.names) printf(\"%s = \", v.as.rec.names[i]);"
  , "        mi_print_val(v.as.rec.fields[i]);"
  , "      }"
  , "      printf(\"}\"); break;"
  , "    case MI_CLOSURE: printf(\"<closure>\"); break;"
  , "    case MI_NATIVE:  printf(\"<closure>\"); break;"
  , "    case MI_POINTER: printf(\"<ptr:%p>\", v.as.ptr); break;"
  , "    case MI_LIST:"
  , "      printf(\"[\");"
  , "      for (int i = 0; i < v.as.list.len; i++) {"
  , "        if (i > 0) printf(\", \");"
  , "        mi_print_val(v.as.list.items[i]);"
  , "      }"
  , "      printf(\"]\"); break;"
  , "  }"
  , "}"
  , "static void mi_println_val(MiVal v) { mi_print_val(v); printf(\"\\n\"); }"
  , ""
  , "// ── Application (non-tail: used outside mi_eval) ──"
  , "static MiVal mi_apply(MiVal f, MiVal arg) {"
  , "  if (f.type == MI_NATIVE) return f.as.native.fn(arg, f.as.native.env);"
  , "  if (f.type == MI_CLOSURE) {"
  , "    MiEnv *call_env = mi_env_new(f.as.closure.env);"
  , "    mi_env_set(call_env, f.as.closure.param, arg);"
  , "    return mi_eval(f.as.closure.body, call_env);"
  , "  }"
  , "  mi_error(NULL, \"apply on non-function\");"
  , "}"
  , ""
  , "// ── Force thunk (non-tail) ──"
  , "static MiVal mi_force(MiVal v, MiEnv *env) {"
  , "  (void)env;"
  , "  if (v.type == MI_CLOSURE && v.as.closure.param && strcmp(v.as.closure.param, \"_thunk_\") == 0)"
  , "    return mi_eval(v.as.closure.body, v.as.closure.env);"
  , "  return v;"
  , "}"
  , ""
  , "// ── Pattern matching ──"
  , "static int mi_match(MiPat *pat, MiVal val, MiEnv *env) {"
  , "  switch (pat->type) {"
  , "    case PAT_VAR:    mi_env_set(env, pat->as.var, val); return 1;"
  , "    case PAT_WILD:   return 1;"
  , "    case PAT_INT:    return val.type == MI_INT && val.as.i == pat->as.i;"
  , "    case PAT_STRING: return val.type == MI_STRING && strcmp(val.as.str.data, pat->as.s) == 0;"
  , "    case PAT_REC:"
  , "      if (val.type != MI_RECORD || strcmp(val.as.rec.tag, pat->as.rec.tag) != 0) return 0;"
  , "      for (int i = 0; i < pat->as.rec.nfields; i++) {"
  , "        int found = 0;"
  , "        for (int j = 0; j < val.as.rec.nfields; j++) {"
  , "          if (strcmp(val.as.rec.names[j], pat->as.rec.field_names[i]) == 0) {"
  , "            if (!mi_match(pat->as.rec.field_pats[i], val.as.rec.fields[j], env)) return 0;"
  , "            found = 1; break;"
  , "          }"
  , "        }"
  , "        if (!found) return 0;"
  , "      }"
  , "      return 1;"
  , "    case PAT_LIST:"
  , "      if (val.type != MI_LIST) return 0;"
  , "      if (pat->as.list.rest == NULL && val.as.list.len != pat->as.list.npats) return 0;"
  , "      if (pat->as.list.rest != NULL && val.as.list.len < pat->as.list.npats) return 0;"
  , "      for (int i = 0; i < pat->as.list.npats; i++)"
  , "        if (!mi_match(pat->as.list.pats[i], val.as.list.items[i], env)) return 0;"
  , "      if (pat->as.list.rest) {"
  , "        int rlen = val.as.list.len - pat->as.list.npats;"
  , "        MiVal *ritems = malloc(rlen * sizeof(MiVal));"
  , "        for (int i = 0; i < rlen; i++) ritems[i] = val.as.list.items[pat->as.list.npats + i];"
  , "        mi_env_set(env, pat->as.list.rest, mi_list(ritems, rlen));"
  , "      }"
  , "      return 1;"
  , "  }"
  , "  return 0;"
  , "}"
  , ""
  , "// ── Arithmetic ──"
  , "static MiVal mi_binop(const char *op, MiVal a, MiVal b) {"
  , "  if (strcmp(op, \"+\") == 0 && a.type == MI_STRING && b.type == MI_STRING) {"
  , "    int la = a.as.str.len, lb = b.as.str.len;"
  , "    char *r = malloc(la + lb + 1); memcpy(r, a.as.str.data, la); memcpy(r+la, b.as.str.data, lb); r[la+lb] = '\\0';"
  , "    MiVal v; v.type = MI_STRING; v.as.str.data = r; v.as.str.len = la + lb; return v;"
  , "  }"
  , "  if (a.type == MI_STRING && b.type == MI_STRING) {"
  , "    int cmp = strcmp(a.as.str.data, b.as.str.data);"
  , "    if (strcmp(op, \"==\") == 0) return mi_int(cmp == 0);"
  , "    if (strcmp(op, \"/=\") == 0) return mi_int(cmp != 0);"
  , "    if (strcmp(op, \"<\") == 0) return mi_int(cmp < 0);"
  , "    if (strcmp(op, \">\") == 0) return mi_int(cmp > 0);"
  , "    if (strcmp(op, \"<=\") == 0) return mi_int(cmp <= 0);"
  , "    if (strcmp(op, \">=\") == 0) return mi_int(cmp >= 0);"
  , "  }"
  , "  if (a.type == MI_FLOAT || b.type == MI_FLOAT) {"
  , "    double fa = mi_to_float(a), fb = mi_to_float(b);"
  , "    if (strcmp(op, \"+\") == 0) return mi_float(fa + fb);"
  , "    if (strcmp(op, \"-\") == 0) return mi_float(fa - fb);"
  , "    if (strcmp(op, \"*\") == 0) return mi_float(fa * fb);"
  , "    if (strcmp(op, \"/\") == 0) return mi_float(fa / fb);"
  , "    if (strcmp(op, \"**\") == 0) return mi_float(pow(fa, fb));"
  , "    if (strcmp(op, \"==\") == 0) return mi_int(fa == fb);"
  , "    if (strcmp(op, \"/=\") == 0) return mi_int(fa != fb);"
  , "    if (strcmp(op, \"<\") == 0) return mi_int(fa < fb);"
  , "    if (strcmp(op, \">\") == 0) return mi_int(fa > fb);"
  , "    if (strcmp(op, \"<=\") == 0) return mi_int(fa <= fb);"
  , "    if (strcmp(op, \">=\") == 0) return mi_int(fa >= fb);"
  , "  }"
  , "  int64_t ia = a.as.i, ib = b.as.i;"
  , "  if (strcmp(op, \"+\") == 0) return mi_int(ia + ib);"
  , "  if (strcmp(op, \"-\") == 0) return mi_int(ia - ib);"
  , "  if (strcmp(op, \"*\") == 0) return mi_int(ia * ib);"
  , "  if (strcmp(op, \"/\") == 0) { if (ib==0) { fprintf(stderr,\"division by zero\\n\"); exit(1); } return mi_int(ia / ib); }"
  , "  if (strcmp(op, \"**\") == 0) { int64_t r=1; for(int64_t e=ib;e>0;e--) r*=ia; return mi_int(r); }"
  , "  if (strcmp(op, \"==\") == 0) return mi_int(ia == ib);"
  , "  if (strcmp(op, \"/=\") == 0) return mi_int(ia != ib);"
  , "  if (strcmp(op, \"<\") == 0) return mi_int(ia < ib);"
  , "  if (strcmp(op, \">\") == 0) return mi_int(ia > ib);"
  , "  if (strcmp(op, \"<=\") == 0) return mi_int(ia <= ib);"
  , "  if (strcmp(op, \">=\") == 0) return mi_int(ia >= ib);"
  , "  fprintf(stderr, \"unknown operator: %s\\n\", op); exit(1);"
  , "}"
  , ""
  , "// ── Wrap params ──"
  , "static MiExpr *mi_wrap_lambda(int nparams, char **params, MiExpr *body) {"
  , "  MiExpr *e = body;"
  , "  for (int i = nparams - 1; i >= 0; i--) e = mi_expr_lam(params[i], e);"
  , "  return e;"
  , "}"
  , ""
  , "// ── Evaluator (with TCO trampoline) ──"
  , "static MiVal mi_eval(MiExpr *expr, MiEnv *env) {"
  , "  eval_top:;"
  , "  switch (expr->type) {"
  , "    case EXPR_INT:    return mi_int(expr->as.i);"
  , "    case EXPR_FLOAT:  return mi_float(expr->as.f);"
  , "    case EXPR_STRING: return mi_string(expr->as.s);"
  , "    case EXPR_VAL:    return expr->as.val;"
  , "    case EXPR_NAME:   return mi_env_get_loc(env, expr->as.name, expr->loc);"
  , ""
  , "    case EXPR_BINOP: {"
  , "      MiVal l = mi_eval(expr->as.binop.left, env);"
  , "      MiVal r = mi_eval(expr->as.binop.right, env);"
  , "      return mi_binop(expr->as.binop.op, l, r);"
  , "    }"
  , ""
  , "    case EXPR_APP: {"
  , "      MiVal fn = mi_eval(expr->as.app.fn, env);"
  , "      MiVal a = mi_eval(expr->as.app.arg, env);"
  , "      // TCO: if fn is a closure, trampoline instead of recursing"
  , "      if (fn.type == MI_CLOSURE) {"
  , "        MiEnv *call_env = mi_env_new(fn.as.closure.env);"
  , "        mi_env_set(call_env, fn.as.closure.param, a);"
  , "        expr = fn.as.closure.body; env = call_env; goto eval_top;"
  , "      }"
  , "      if (fn.type == MI_NATIVE) {"
  , "        MiVal result = fn.as.native.fn(a, fn.as.native.env);"
  , "        // TCO: if native returned a thunk, trampoline into it"
  , "        if (result.type == MI_CLOSURE && result.as.closure.param"
  , "            && strcmp(result.as.closure.param, \"_thunk_\") == 0) {"
  , "          expr = result.as.closure.body; env = result.as.closure.env; goto eval_top;"
  , "        }"
  , "        return result;"
  , "      }"
  , "      mi_error(expr->loc, \"apply on non-function\");"  , "    }"
  , ""
  , "    case EXPR_LAM: {"
  , "      MiVal r; r.type = MI_CLOSURE;"
  , "      r.as.closure.body = expr->as.lam.body;"
  , "      r.as.closure.param = expr->as.lam.param;"
  , "      r.as.closure.env = env;"
  , "      return r;"
  , "    }"
  , ""
  , "    case EXPR_WITH: {"
  , "      MiEnv *inner = mi_env_new(env);"
  , "      for (int i = 0; i < expr->as.with.nbindings; i++) {"
  , "        MiBinding *b = &expr->as.with.bindings[i];"
  , "        MiExpr *body = b->nparams > 0 ? mi_wrap_lambda(b->nparams, b->params, b->body) : b->body;"
  , "        if (b->lazy) {"
  , "          MiVal thunk; thunk.type = MI_CLOSURE;"
  , "          thunk.as.closure.body = body; thunk.as.closure.param = \"_thunk_\";"
  , "          thunk.as.closure.env = inner;"
  , "          mi_env_set(inner, b->name, thunk);"
  , "        } else {"
  , "          mi_env_set(inner, b->name, mi_eval(body, inner));"
  , "        }"
  , "      }"
  , "      // TCO: tail position"
  , "      expr = expr->as.with.body; env = inner; goto eval_top;"
  , "    }"
  , ""
  , "    case EXPR_RECORD: {"
  , "      int n = expr->as.record.nbindings;"
  , "      MiVal *fields = malloc(n * sizeof(MiVal));"
  , "      const char **names = malloc(n * sizeof(char*));"
  , "      for (int i = 0; i < n; i++) {"
  , "        MiBinding *b = &expr->as.record.bindings[i];"
  , "        names[i] = b->name;"
  , "        MiExpr *body = b->nparams > 0 ? mi_wrap_lambda(b->nparams, b->params, b->body) : b->body;"
  , "        fields[i] = mi_eval(body, env);"
  , "      }"
  , "      MiVal r; r.type = MI_RECORD;"
  , "      r.as.rec.tag = expr->as.record.tag; r.as.rec.names = names;"
  , "      r.as.rec.fields = fields; r.as.rec.nfields = n;"
  , "      return r;"
  , "    }"
  , ""
  , "    case EXPR_FIELD: {"
  , "      MiVal v = mi_eval(expr->as.field.expr, env);"
  , "      v = mi_force(v, env);"
  , "      return mi_field_loc(v, expr->as.field.field, expr->loc);"
  , "    }"
  , ""
  , "    case EXPR_NAMESPACE: {"
  , "      MiEnv *inner = mi_env_new(env);"
  , "      int n = expr->as.ns.nbindings;"
  , "      MiVal *vals = malloc(n * sizeof(MiVal));"
  , "      const char **names = malloc(n * sizeof(const char *));"
  , "      for (int i = 0; i < n; i++) {"
  , "        MiBinding *b = &expr->as.ns.bindings[i];"
  , "        MiExpr *body = b->nparams > 0 ? mi_wrap_lambda(b->nparams, b->params, b->body) : b->body;"
  , "        names[i] = b->name;"
  , "        if (b->lazy) {"
  , "          MiVal thunk; thunk.type = MI_CLOSURE;"
  , "          thunk.as.closure.body = body; thunk.as.closure.param = \"_thunk_\";"
  , "          thunk.as.closure.env = inner;"
  , "          mi_env_set(inner, b->name, thunk); vals[i] = thunk;"
  , "        } else {"
  , "          vals[i] = mi_eval(body, inner);"
  , "          mi_env_set(inner, b->name, vals[i]);"
  , "        }"
  , "      }"
  , "      MiVal rec; rec.type = MI_RECORD;"
  , "      rec.as.rec.tag = \"_module_\";"
  , "      rec.as.rec.nfields = n;"
  , "      rec.as.rec.names = names;"
  , "      rec.as.rec.fields = vals;"
  , "      return rec;"
  , "    }"
  , ""
  , "    case EXPR_CASE: {"
  , "      MiVal scrut = mi_eval(expr->as.cas.scrut, env);"
  , "      scrut = mi_force(scrut, env);"
  , "      for (int i = 0; i < expr->as.cas.nalts; i++) {"
  , "        MiEnv *match_env = mi_env_new(env);"
  , "        if (mi_match(expr->as.cas.alts[i].pat, scrut, match_env)) {"
  , "          // TCO: tail position"
  , "          expr = expr->as.cas.alts[i].body; env = match_env; goto eval_top;"
  , "        }"
  , "      }"
  , "      mi_error(expr->loc, \"match: no matching pattern\");"
  , "    }"
  , ""
  , "    case EXPR_THUNK: {"
  , "      MiVal r; r.type = MI_CLOSURE;"
  , "      r.as.closure.body = expr->as.thunk.body;"
  , "      r.as.closure.param = \"_thunk_\";"
  , "      r.as.closure.env = env;"
  , "      return r;"
  , "    }"
  , ""
  , "    case EXPR_LIST: {"
  , "      int n = expr->as.list.len;"
  , "      MiVal *items = malloc(n * sizeof(MiVal));"
  , "      for (int i = 0; i < n; i++) items[i] = mi_eval(expr->as.list.items[i], env);"
  , "      return mi_list(items, n);"
  , "    }"
  , ""
  , "    case EXPR_RECORD_UPDATE: {"
  , "      MiVal base = mi_eval(expr->as.rupd.base, env);"
  , "      if (base.type != MI_RECORD) { mi_error(expr->loc, \"record update on non-record\"); }"
  , "      int n = base.as.rec.nfields;"
  , "      int nu = expr->as.rupd.nupdates;"
  , "      // Count new fields (not in base)"
  , "      int extra = 0;"
  , "      for (int u = 0; u < nu; u++) {"
  , "        int found = 0;"
  , "        for (int i = 0; i < n; i++) {"
  , "          if (strcmp(expr->as.rupd.updates[u].name, base.as.rec.names[i]) == 0) { found = 1; break; }"
  , "        }"
  , "        if (!found) extra++;"
  , "      }"
  , "      int total = n + extra;"
  , "      const char **names = malloc(total * sizeof(const char*));"
  , "      MiVal *fields = malloc(total * sizeof(MiVal));"
  , "      // Copy base fields, overriding matches"
  , "      for (int i = 0; i < n; i++) {"
  , "        names[i] = base.as.rec.names[i];"
  , "        int overridden = 0;"
  , "        for (int u = 0; u < nu; u++) {"
  , "          if (strcmp(expr->as.rupd.updates[u].name, names[i]) == 0) {"
  , "            MiExpr *body = expr->as.rupd.updates[u].body;"
  , "            fields[i] = mi_eval(body, env); overridden = 1; break;"
  , "          }"
  , "        }"
  , "        if (!overridden) fields[i] = base.as.rec.fields[i];"
  , "      }"
  , "      // Add new fields"
  , "      int idx = n;"
  , "      for (int u = 0; u < nu; u++) {"
  , "        int found = 0;"
  , "        for (int i = 0; i < n; i++) {"
  , "          if (strcmp(expr->as.rupd.updates[u].name, base.as.rec.names[i]) == 0) { found = 1; break; }"
  , "        }"
  , "        if (!found) {"
  , "          names[idx] = expr->as.rupd.updates[u].name;"
  , "          fields[idx] = mi_eval(expr->as.rupd.updates[u].body, env);"
  , "          idx++;"
  , "        }"
  , "      }"
  , "      MiVal r; r.type = MI_RECORD; r.as.rec.tag = base.as.rec.tag;"
  , "      r.as.rec.nfields = total; r.as.rec.names = names; r.as.rec.fields = fields;"
  , "      return r;"
  , "    }"
  , "  }"
  , "  mi_errorf(expr->loc, \"eval: unknown expr type %d\", expr->type);"
  , "}"
  , ""
  , "// ── Built-ins ──"
  , "static MiVal mi_builtin_print(MiVal v, void *e) { (void)e; mi_print_val(v); return mi_int(0); }"
  , "static MiVal mi_builtin_println(MiVal v, void *e) { (void)e; mi_println_val(v); return mi_int(0); }"
  , ""
  , "// if: 3-arg curried (returns thunk unforced for TCO)"
  , "struct mi_if_env2 { MiVal cond; MiVal then_val; };"
  , "static MiVal mi_builtin_if3(MiVal else_val, void *env) {"
  , "  struct mi_if_env2 *e = (struct mi_if_env2 *)env;"
  , "  if (e->cond.as.i != 0) return e->then_val;"
  , "  return else_val;"
  , "}"
  , "struct mi_if_env1 { MiVal cond; };"
  , "static MiVal mi_builtin_if2(MiVal then_val, void *env) {"
  , "  struct mi_if_env1 *e = (struct mi_if_env1 *)env;"
  , "  struct mi_if_env2 *e2 = malloc(sizeof(struct mi_if_env2));"
  , "  e2->cond = e->cond; e2->then_val = then_val;"
  , "  return mi_native_env(mi_builtin_if3, e2);"
  , "}"
  , "static MiVal mi_builtin_if(MiVal cond, void *env) {"
  , "  (void)env; struct mi_if_env1 *e = malloc(sizeof(struct mi_if_env1));"
  , "  e->cond = cond; return mi_native_env(mi_builtin_if2, e);"
  , "}"
  , ""
  , "// List built-ins"
  , "static MiVal mi_builtin_len(MiVal v, void *e) {"
  , "  (void)e;"
  , "  if (v.type == MI_LIST) return mi_int(v.as.list.len);"
  , "  if (v.type == MI_STRING) return mi_int(v.as.str.len);"
  , "  fprintf(stderr, \"len: unsupported type\\n\"); exit(1);"
  , "}"
  , ""
  , "struct mi_get_env { MiVal lst; };"
  , "static MiVal mi_builtin_get2(MiVal idx, void *env) {"
  , "  struct mi_get_env *e = (struct mi_get_env *)env;"
  , "  int i = (int)idx.as.i;"
  , "  if (i < 0 || i >= e->lst.as.list.len) { fprintf(stderr, \"list index out of range\\n\"); exit(1); }"
  , "  return e->lst.as.list.items[i];"
  , "}"
  , "static MiVal mi_builtin_get(MiVal lst, void *env) {"
  , "  (void)env; struct mi_get_env *e = malloc(sizeof(struct mi_get_env));"
  , "  e->lst = lst; return mi_native_env(mi_builtin_get2, e);"
  , "}"
  , ""
  , "struct mi_push_env { MiVal lst; };"
  , "static MiVal mi_builtin_push2(MiVal val, void *env) {"
  , "  struct mi_push_env *e = (struct mi_push_env *)env;"
  , "  int n = e->lst.as.list.len; MiVal *items = malloc((n+1) * sizeof(MiVal));"
  , "  for (int i = 0; i < n; i++) items[i] = e->lst.as.list.items[i];"
  , "  items[n] = val; return mi_list(items, n+1);"
  , "}"
  , "static MiVal mi_builtin_push(MiVal lst, void *env) {"
  , "  (void)env; struct mi_push_env *e = malloc(sizeof(struct mi_push_env));"
  , "  e->lst = lst; return mi_native_env(mi_builtin_push2, e);"
  , "}"
  , ""
  , "struct mi_concat_env { MiVal a; };"
  , "static MiVal mi_builtin_concat2(MiVal b, void *env) {"
  , "  struct mi_concat_env *e = (struct mi_concat_env *)env;"
  , "  int na = e->a.as.list.len, nb = b.as.list.len;"
  , "  MiVal *items = malloc((na+nb) * sizeof(MiVal));"
  , "  for (int i = 0; i < na; i++) items[i] = e->a.as.list.items[i];"
  , "  for (int i = 0; i < nb; i++) items[na+i] = b.as.list.items[i];"
  , "  return mi_list(items, na+nb);"
  , "}"
  , "static MiVal mi_builtin_concat(MiVal a, void *env) {"
  , "  (void)env; struct mi_concat_env *e = malloc(sizeof(struct mi_concat_env));"
  , "  e->a = a; return mi_native_env(mi_builtin_concat2, e);"
  , "}"
  , ""
  , "struct mi_map_env { MiVal fn; };"
  , "static MiVal mi_builtin_map2(MiVal lst, void *env) {"
  , "  struct mi_map_env *e = (struct mi_map_env *)env;"
  , "  int n = lst.as.list.len; MiVal *items = malloc(n * sizeof(MiVal));"
  , "  for (int i = 0; i < n; i++) items[i] = mi_apply(e->fn, lst.as.list.items[i]);"
  , "  return mi_list(items, n);"
  , "}"
  , "static MiVal mi_builtin_map(MiVal fn, void *env) {"
  , "  (void)env; struct mi_map_env *e = malloc(sizeof(struct mi_map_env));"
  , "  e->fn = fn; return mi_native_env(mi_builtin_map2, e);"
  , "}"
  , ""
  , "struct mi_fold_env1 { MiVal fn; };"
  , "struct mi_fold_env2 { MiVal fn; MiVal acc; };"
  , "static MiVal mi_builtin_fold3(MiVal lst, void *env) {"
  , "  struct mi_fold_env2 *e = (struct mi_fold_env2 *)env;"
  , "  MiVal acc = e->acc;"
  , "  for (int i = 0; i < lst.as.list.len; i++)"
  , "    acc = mi_apply(mi_apply(e->fn, acc), lst.as.list.items[i]);"
  , "  return acc;"
  , "}"
  , "static MiVal mi_builtin_fold2(MiVal acc, void *env) {"
  , "  struct mi_fold_env1 *e1 = (struct mi_fold_env1 *)env;"
  , "  struct mi_fold_env2 *e2 = malloc(sizeof(struct mi_fold_env2));"
  , "  e2->fn = e1->fn; e2->acc = acc; return mi_native_env(mi_builtin_fold3, e2);"
  , "}"
  , "static MiVal mi_builtin_fold(MiVal fn, void *env) {"
  , "  (void)env; struct mi_fold_env1 *e = malloc(sizeof(struct mi_fold_env1));"
  , "  e->fn = fn; return mi_native_env(mi_builtin_fold2, e);"
  , "}"
  , ""
  , "struct mi_filter_env { MiVal fn; };"
  , "static MiVal mi_builtin_filter2(MiVal lst, void *env) {"
  , "  struct mi_filter_env *e = (struct mi_filter_env *)env;"
  , "  int n = lst.as.list.len; MiVal *items = malloc(n * sizeof(MiVal)); int count = 0;"
  , "  for (int i = 0; i < n; i++) {"
  , "    MiVal r = mi_apply(e->fn, lst.as.list.items[i]);"
  , "    if (r.as.i != 0) items[count++] = lst.as.list.items[i];"
  , "  }"
  , "  return mi_list(items, count);"
  , "}"
  , "static MiVal mi_builtin_filter(MiVal fn, void *env) {"
  , "  (void)env; struct mi_filter_env *e = malloc(sizeof(struct mi_filter_env));"
  , "  e->fn = fn; return mi_native_env(mi_builtin_filter2, e);"
  , "}"
  , ""
  , "// ── String built-ins ──"
  , ""
  , "// charAt str idx → single-character string"
  , "struct mi_charAt_env { MiVal str; };"
  , "static MiVal mi_builtin_charAt2(MiVal idx, void *env) {"
  , "  struct mi_charAt_env *e = (struct mi_charAt_env *)env;"
  , "  int i = (int)idx.as.i;"
  , "  if (i < 0 || i >= e->str.as.str.len) { fprintf(stderr, \"charAt: index out of range\\n\"); exit(1); }"
  , "  return mi_stringn(e->str.as.str.data + i, 1);"
  , "}"
  , "static MiVal mi_builtin_charAt(MiVal str, void *env) {"
  , "  (void)env; struct mi_charAt_env *e = malloc(sizeof(struct mi_charAt_env));"
  , "  e->str = str; return mi_native_env(mi_builtin_charAt2, e);"
  , "}"
  , ""
  , "// slice str start end → substring [start, end)"
  , "struct mi_slice_env1 { MiVal str; };"
  , "struct mi_slice_env2 { MiVal str; int start; };"
  , "static MiVal mi_builtin_slice3(MiVal end_val, void *env) {"
  , "  struct mi_slice_env2 *e = (struct mi_slice_env2 *)env;"
  , "  int s = e->start, n = e->str.as.str.len;"
  , "  int end = (int)end_val.as.i;"
  , "  if (s < 0) s = 0; if (end > n) end = n; if (s > end) s = end;"
  , "  return mi_stringn(e->str.as.str.data + s, end - s);"
  , "}"
  , "static MiVal mi_builtin_slice2(MiVal start, void *env) {"
  , "  struct mi_slice_env1 *e1 = (struct mi_slice_env1 *)env;"
  , "  struct mi_slice_env2 *e2 = malloc(sizeof(struct mi_slice_env2));"
  , "  e2->str = e1->str; e2->start = (int)start.as.i;"
  , "  return mi_native_env(mi_builtin_slice3, e2);"
  , "}"
  , "static MiVal mi_builtin_slice(MiVal str, void *env) {"
  , "  (void)env; struct mi_slice_env1 *e = malloc(sizeof(struct mi_slice_env1));"
  , "  e->str = str; return mi_native_env(mi_builtin_slice2, e);"
  , "}"
  , ""
  , "// indexOf haystack needle → int (-1 if not found)"
  , "struct mi_indexOf_env { MiVal haystack; };"
  , "static MiVal mi_builtin_indexOf2(MiVal needle, void *env) {"
  , "  struct mi_indexOf_env *e = (struct mi_indexOf_env *)env;"
  , "  char *p = strstr(e->haystack.as.str.data, needle.as.str.data);"
  , "  return mi_int(p ? (int64_t)(p - e->haystack.as.str.data) : -1);"
  , "}"
  , "static MiVal mi_builtin_indexOf(MiVal haystack, void *env) {"
  , "  (void)env; struct mi_indexOf_env *e = malloc(sizeof(struct mi_indexOf_env));"
  , "  e->haystack = haystack; return mi_native_env(mi_builtin_indexOf2, e);"
  , "}"
  , ""
  , "// split str delim → list of strings"
  , "struct mi_split_env { MiVal str; };"
  , "static MiVal mi_builtin_split2(MiVal delim, void *env) {"
  , "  struct mi_split_env *e = (struct mi_split_env *)env;"
  , "  int dlen = delim.as.str.len;"
  , "  if (dlen == 0) {"
  , "    // Split into individual characters"
  , "    int n = e->str.as.str.len;"
  , "    MiVal *items = malloc(n * sizeof(MiVal));"
  , "    for (int i = 0; i < n; i++) items[i] = mi_stringn(e->str.as.str.data + i, 1);"
  , "    return mi_list(items, n);"
  , "  }"
  , "  // Count splits first"
  , "  int cap = 16; int count = 0;"
  , "  MiVal *items = malloc(cap * sizeof(MiVal));"
  , "  const char *p = e->str.as.str.data;"
  , "  const char *end = p + e->str.as.str.len;"
  , "  while (p <= end) {"
  , "    const char *found = strstr(p, delim.as.str.data);"
  , "    if (!found || found >= end) { found = end; }"
  , "    if (count >= cap) { cap *= 2; items = realloc(items, cap * sizeof(MiVal)); }"
  , "    items[count++] = mi_stringn(p, (int)(found - p));"
  , "    if (found == end) break;"
  , "    p = found + dlen;"
  , "  }"
  , "  return mi_list(items, count);"
  , "}"
  , "static MiVal mi_builtin_split(MiVal str, void *env) {"
  , "  (void)env; struct mi_split_env *e = malloc(sizeof(struct mi_split_env));"
  , "  e->str = str; return mi_native_env(mi_builtin_split2, e);"
  , "}"
  , ""
  , "// join delim list → string"
  , "struct mi_join_env { MiVal delim; };"
  , "static MiVal mi_builtin_join2(MiVal lst, void *env) {"
  , "  struct mi_join_env *e = (struct mi_join_env *)env;"
  , "  int n = lst.as.list.len;"
  , "  if (n == 0) return mi_string(\"\");"
  , "  // Calculate total length"
  , "  int total = 0;"
  , "  for (int i = 0; i < n; i++) {"
  , "    total += lst.as.list.items[i].as.str.len;"
  , "    if (i > 0) total += e->delim.as.str.len;"
  , "  }"
  , "  char *buf = malloc(total + 1); int pos = 0;"
  , "  for (int i = 0; i < n; i++) {"
  , "    if (i > 0) { memcpy(buf+pos, e->delim.as.str.data, e->delim.as.str.len); pos += e->delim.as.str.len; }"
  , "    memcpy(buf+pos, lst.as.list.items[i].as.str.data, lst.as.list.items[i].as.str.len);"
  , "    pos += lst.as.list.items[i].as.str.len;"
  , "  }"
  , "  buf[total] = '\\0';"
  , "  MiVal r; r.type = MI_STRING; r.as.str.data = buf; r.as.str.len = total; return r;"
  , "}"
  , "static MiVal mi_builtin_join(MiVal delim, void *env) {"
  , "  (void)env; struct mi_join_env *e = malloc(sizeof(struct mi_join_env));"
  , "  e->delim = delim; return mi_native_env(mi_builtin_join2, e);"
  , "}"
  , ""
  , "// trim str → string (strip leading/trailing whitespace)"
  , "static MiVal mi_builtin_trim(MiVal str, void *env) {"
  , "  (void)env;"
  , "  const char *s = str.as.str.data; int n = str.as.str.len;"
  , "  int start = 0; while (start < n && (s[start]==' '||s[start]=='\\t'||s[start]=='\\n'||s[start]=='\\r')) start++;"
  , "  int end = n; while (end > start && (s[end-1]==' '||s[end-1]=='\\t'||s[end-1]=='\\n'||s[end-1]=='\\r')) end--;"
  , "  return mi_stringn(s + start, end - start);"
  , "}"
  , ""
  , "// toUpper str → string"
  , "static MiVal mi_builtin_toUpper(MiVal str, void *env) {"
  , "  (void)env; int n = str.as.str.len; char *buf = malloc(n+1);"
  , "  for (int i = 0; i < n; i++) buf[i] = toupper((unsigned char)str.as.str.data[i]);"
  , "  buf[n] = '\\0';"
  , "  MiVal r; r.type = MI_STRING; r.as.str.data = buf; r.as.str.len = n; return r;"
  , "}"
  , ""
  , "// toLower str → string"
  , "static MiVal mi_builtin_toLower(MiVal str, void *env) {"
  , "  (void)env; int n = str.as.str.len; char *buf = malloc(n+1);"
  , "  for (int i = 0; i < n; i++) buf[i] = tolower((unsigned char)str.as.str.data[i]);"
  , "  buf[n] = '\\0';"
  , "  MiVal r; r.type = MI_STRING; r.as.str.data = buf; r.as.str.len = n; return r;"
  , "}"
  , ""
  , "// replace str old new → string"
  , "struct mi_replace_env1 { MiVal str; };"
  , "struct mi_replace_env2 { MiVal str; MiVal old; };"
  , "static MiVal mi_builtin_replace3(MiVal new_str, void *env) {"
  , "  struct mi_replace_env2 *e = (struct mi_replace_env2 *)env;"
  , "  if (e->old.as.str.len == 0) return e->str;"
  , "  // Count occurrences"
  , "  int count = 0;"
  , "  const char *p = e->str.as.str.data;"
  , "  while ((p = strstr(p, e->old.as.str.data)) != NULL) { count++; p += e->old.as.str.len; }"
  , "  if (count == 0) return e->str;"
  , "  int new_len = e->str.as.str.len + count * (new_str.as.str.len - e->old.as.str.len);"
  , "  char *buf = malloc(new_len + 1); int pos = 0;"
  , "  p = e->str.as.str.data;"
  , "  while (*p) {"
  , "    const char *found = strstr(p, e->old.as.str.data);"
  , "    if (!found) { int rem = e->str.as.str.len - (int)(p - e->str.as.str.data); memcpy(buf+pos, p, rem); pos += rem; break; }"
  , "    int seg = (int)(found - p); memcpy(buf+pos, p, seg); pos += seg;"
  , "    memcpy(buf+pos, new_str.as.str.data, new_str.as.str.len); pos += new_str.as.str.len;"
  , "    p = found + e->old.as.str.len;"
  , "  }"
  , "  buf[new_len] = '\\0';"
  , "  MiVal r; r.type = MI_STRING; r.as.str.data = buf; r.as.str.len = new_len; return r;"
  , "}"
  , "static MiVal mi_builtin_replace2(MiVal old, void *env) {"
  , "  struct mi_replace_env1 *e1 = (struct mi_replace_env1 *)env;"
  , "  struct mi_replace_env2 *e2 = malloc(sizeof(struct mi_replace_env2));"
  , "  e2->str = e1->str; e2->old = old;"
  , "  return mi_native_env(mi_builtin_replace3, e2);"
  , "}"
  , "static MiVal mi_builtin_replace(MiVal str, void *env) {"
  , "  (void)env; struct mi_replace_env1 *e = malloc(sizeof(struct mi_replace_env1));"
  , "  e->str = str; return mi_native_env(mi_builtin_replace2, e);"
  , "}"
  , ""
  , "// ── Math / conversion built-ins ──"
  , ""
  , "// toString val → string representation"
  , "static MiVal mi_builtin_toString(MiVal v, void *env) {"
  , "  (void)env;"
  , "  char buf[64];"
  , "  if (v.type == MI_INT) { snprintf(buf, sizeof(buf), \"%ld\", v.as.i); return mi_string(buf); }"
  , "  if (v.type == MI_FLOAT) { snprintf(buf, sizeof(buf), \"%g\", v.as.f); return mi_string(buf); }"
  , "  if (v.type == MI_STRING) return v;"
  , "  return mi_string(\"<non-printable>\");"
  , "}"
  , ""
  , "// toInt val → integer (float truncates, string parses)"
  , "static MiVal mi_builtin_toInt(MiVal v, void *env) {"
  , "  (void)env;"
  , "  if (v.type == MI_INT) return v;"
  , "  if (v.type == MI_FLOAT) return mi_int((int64_t)v.as.f);"
  , "  if (v.type == MI_STRING) { return mi_int(atoll(v.as.str.data)); }"
  , "  fprintf(stderr, \"toInt: unsupported type\\n\"); exit(1);"
  , "}"
  , ""
  , "// toFloat val → float (int promotes, string parses)"
  , "static MiVal mi_builtin_toFloat(MiVal v, void *env) {"
  , "  (void)env;"
  , "  if (v.type == MI_FLOAT) return v;"
  , "  if (v.type == MI_INT) return mi_float((double)v.as.i);"
  , "  if (v.type == MI_STRING) { return mi_float(atof(v.as.str.data)); }"
  , "  fprintf(stderr, \"toFloat: unsupported type\\n\"); exit(1);"
  , "}"
  , ""
  , "// abs val → absolute value (int or float)"
  , "static MiVal mi_builtin_abs(MiVal v, void *env) {"
  , "  (void)env;"
  , "  if (v.type == MI_INT) return mi_int(v.as.i < 0 ? -v.as.i : v.as.i);"
  , "  if (v.type == MI_FLOAT) return mi_float(v.as.f < 0 ? -v.as.f : v.as.f);"
  , "  fprintf(stderr, \"abs: unsupported type\\n\"); exit(1);"
  , "}"
  , ""
  , "// min a b → smaller value (dispatches on type)"
  , "struct mi_min_env { MiVal a; };"
  , "static MiVal mi_builtin_min2(MiVal b, void *env) {"
  , "  struct mi_min_env *e = (struct mi_min_env *)env;"
  , "  if (e->a.type == MI_FLOAT || b.type == MI_FLOAT) {"
  , "    double fa = mi_to_float(e->a), fb = mi_to_float(b);"
  , "    return mi_float(fa < fb ? fa : fb);"
  , "  }"
  , "  return mi_int(e->a.as.i < b.as.i ? e->a.as.i : b.as.i);"
  , "}"
  , "static MiVal mi_builtin_min(MiVal a, void *env) {"
  , "  (void)env; struct mi_min_env *e = malloc(sizeof(struct mi_min_env));"
  , "  e->a = a; return mi_native_env(mi_builtin_min2, e);"
  , "}"
  , ""
  , "// max a b → larger value (dispatches on type)"
  , "struct mi_max_env { MiVal a; };"
  , "static MiVal mi_builtin_max2(MiVal b, void *env) {"
  , "  struct mi_max_env *e = (struct mi_max_env *)env;"
  , "  if (e->a.type == MI_FLOAT || b.type == MI_FLOAT) {"
  , "    double fa = mi_to_float(e->a), fb = mi_to_float(b);"
  , "    return mi_float(fa > fb ? fa : fb);"
  , "  }"
  , "  return mi_int(e->a.as.i > b.as.i ? e->a.as.i : b.as.i);"
  , "}"
  , "static MiVal mi_builtin_max(MiVal a, void *env) {"
  , "  (void)env; struct mi_max_env *e = malloc(sizeof(struct mi_max_env));"
  , "  e->a = a; return mi_native_env(mi_builtin_max2, e);"
  , "}"
  , ""
  , "// ── World / Capability-based IO ──"
  , ""
  , "// Helper: build Ok {value = v}"
  , "static MiVal mi_ok(MiVal v) {"
  , "  MiVal r; r.type = MI_RECORD; r.as.rec.tag = \"Ok\";"
  , "  r.as.rec.nfields = 1;"
  , "  r.as.rec.names = malloc(sizeof(const char*)); r.as.rec.names[0] = \"value\";"
  , "  r.as.rec.fields = malloc(sizeof(MiVal)); r.as.rec.fields[0] = v;"
  , "  return r;"
  , "}"
  , ""
  , "// Helper: build Err {msg = s}"
  , "static MiVal mi_err(const char *msg) {"
  , "  MiVal r; r.type = MI_RECORD; r.as.rec.tag = \"Err\";"
  , "  r.as.rec.nfields = 1;"
  , "  r.as.rec.names = malloc(sizeof(const char*)); r.as.rec.names[0] = \"msg\";"
  , "  r.as.rec.fields = malloc(sizeof(MiVal)); r.as.rec.fields[0] = mi_string(msg);"
  , "  return r;"
  , "}"
  , ""
  , "// Helper: build None {}"
  , "static MiVal mi_none(void) {"
  , "  MiVal r; r.type = MI_RECORD; r.as.rec.tag = \"None\";"
  , "  r.as.rec.nfields = 0; r.as.rec.names = NULL; r.as.rec.fields = NULL;"
  , "  return r;"
  , "}"
  , ""
  , "// world.io.readFile path → Ok {value=contents} / Err {msg=...}"
  , "static MiVal mi_world_readFile(MiVal path, void *env) {"
  , "  (void)env;"
  , "  FILE *f = fopen(path.as.str.data, \"r\");"
  , "  if (!f) {"
  , "    char buf[512]; snprintf(buf, sizeof(buf), \"Cannot open file: %s\", path.as.str.data);"
  , "    return mi_err(buf);"
  , "  }"
  , "  fseek(f, 0, SEEK_END); long len = ftell(f); fseek(f, 0, SEEK_SET);"
  , "  char *contents = malloc(len + 1);"
  , "  long nread = fread(contents, 1, len, f); contents[nread] = '\\0'; fclose(f);"
  , "  return mi_ok(mi_stringn(contents, (int)nread));"
  , "}"
  , ""
  , "// world.io.writeFile path contents → Ok {value=0} / Err {msg=...}"
  , "struct mi_wf_env { MiVal path; };"
  , "static MiVal mi_world_writeFile2(MiVal contents, void *env) {"
  , "  struct mi_wf_env *e = (struct mi_wf_env *)env;"
  , "  FILE *f = fopen(e->path.as.str.data, \"w\");"
  , "  if (!f) {"
  , "    char buf[512]; snprintf(buf, sizeof(buf), \"Cannot write file: %s\", e->path.as.str.data);"
  , "    return mi_err(buf);"
  , "  }"
  , "  fwrite(contents.as.str.data, 1, contents.as.str.len, f); fclose(f);"
  , "  return mi_ok(mi_int(0));"
  , "}"
  , "static MiVal mi_world_writeFile(MiVal path, void *env) {"
  , "  (void)env; struct mi_wf_env *e = malloc(sizeof(struct mi_wf_env));"
  , "  e->path = path; return mi_native_env(mi_world_writeFile2, e);"
  , "}"
  , ""
  , "// world.io.appendFile path contents → Ok {value=0} / Err {msg=...}"
  , "static MiVal mi_world_appendFile2(MiVal contents, void *env) {"
  , "  struct mi_wf_env *e = (struct mi_wf_env *)env;"
  , "  FILE *f = fopen(e->path.as.str.data, \"a\");"
  , "  if (!f) {"
  , "    char buf[512]; snprintf(buf, sizeof(buf), \"Cannot append file: %s\", e->path.as.str.data);"
  , "    return mi_err(buf);"
  , "  }"
  , "  fwrite(contents.as.str.data, 1, contents.as.str.len, f); fclose(f);"
  , "  return mi_ok(mi_int(0));"
  , "}"
  , "static MiVal mi_world_appendFile(MiVal path, void *env) {"
  , "  (void)env; struct mi_wf_env *e = malloc(sizeof(struct mi_wf_env));"
  , "  e->path = path; return mi_native_env(mi_world_appendFile2, e);"
  , "}"
  , ""
  , "// world.io.exists path → 1/0"
  , "static MiVal mi_world_exists(MiVal path, void *env) {"
  , "  (void)env; FILE *f = fopen(path.as.str.data, \"r\");"
  , "  if (f) { fclose(f); return mi_int(1); }"
  , "  return mi_int(0);"
  , "}"
  , ""
  , "// world.io.remove path → Ok {value=0} / Err {msg=...}"
  , "static MiVal mi_world_remove(MiVal path, void *env) {"
  , "  (void)env;"
  , "  if (remove(path.as.str.data) == 0) return mi_ok(mi_int(0));"
  , "  char buf[512]; snprintf(buf, sizeof(buf), \"Cannot remove: %s\", path.as.str.data);"
  , "  return mi_err(buf);"
  , "}"
  , ""
  , "// world.io.readLine prompt → string (prints prompt, reads line)"
  , "static MiVal mi_world_readLine(MiVal prompt, void *env) {"
  , "  (void)env;"
  , "  if (prompt.type == MI_STRING && prompt.as.str.len > 0) {"
  , "    printf(\"%.*s\", prompt.as.str.len, prompt.as.str.data); fflush(stdout);"
  , "  }"
  , "  char buf[4096];"
  , "  if (fgets(buf, sizeof(buf), stdin)) {"
  , "    size_t len = strlen(buf);"
  , "    if (len > 0 && buf[len-1] == '\\n') buf[len-1] = '\\0';"
  , "    return mi_string(buf);"
  , "  }"
  , "  return mi_string(\"\");"
  , "}"
  , ""
  , "// world.getEnv name → Ok {value=val} / None {}"
  , "static MiVal mi_world_getEnv(MiVal name, void *env) {"
  , "  (void)env;"
  , "  const char *val = getenv(name.as.str.data);"
  , "  if (val) return mi_ok(mi_string(val));"
  , "  return mi_none();"
  , "}"
  , ""
  , "// world.process.exec cmd args → Ok {value=output} / Err {msg=...}"
  , "struct mi_exec_env { MiVal cmd; };"
  , "static MiVal mi_world_exec2(MiVal args, void *env) {"
  , "  struct mi_exec_env *e = (struct mi_exec_env *)env;"
  , "  // Build command string: cmd + space-separated args"
  , "  char cmdline[8192];"
  , "  int pos = snprintf(cmdline, sizeof(cmdline), \"%s\", e->cmd.as.str.data);"
  , "  for (int i = 0; i < args.as.list.len && pos < (int)sizeof(cmdline)-1; i++) {"
  , "    MiVal a = args.as.list.items[i];"
  , "    pos += snprintf(cmdline + pos, sizeof(cmdline) - pos, \" %s\", a.as.str.data);"
  , "  }"
  , "  FILE *p = popen(cmdline, \"r\");"
  , "  if (!p) return mi_err(\"Failed to execute command\");"
  , "  char *output = malloc(65536); size_t total = 0; size_t n;"
  , "  while ((n = fread(output + total, 1, 65536 - total - 1, p)) > 0) total += n;"
  , "  output[total] = '\\0';"
  , "  int status = pclose(p);"
  , "  if (status != 0) {"
  , "    char buf[512]; snprintf(buf, sizeof(buf), \"Command exited with status %d\", status);"
  , "    free(output); return mi_err(buf);"
  , "  }"
  , "  return mi_ok(mi_stringn(output, (int)total));"
  , "}"
  , "static MiVal mi_world_exec(MiVal cmd, void *env) {"
  , "  (void)env; struct mi_exec_env *e = malloc(sizeof(struct mi_exec_env));"
  , "  e->cmd = cmd; return mi_native_env(mi_world_exec2, e);"
  , "}"
  , ""
  , "// world.process.exit code → (never returns)"
  , "static MiVal mi_world_exit(MiVal code, void *env) {"
  , "  (void)env; exit((int)code.as.i);"
  , "  return mi_int(0); // unreachable"
  , "}"
  , ""
  , "// Helper: build a record from parallel name/value arrays"
  , "static MiVal mi_make_record(const char *tag, int n, const char **names, MiVal *fields) {"
  , "  MiVal r; r.type = MI_RECORD; r.as.rec.tag = tag;"
  , "  r.as.rec.nfields = n; r.as.rec.names = names; r.as.rec.fields = fields;"
  , "  return r;"
  , "}"
  , ""
  , "// Build the world record: {argv, time, getEnv, io={...}, process={...}}"
  , "static MiVal mi_build_world(int argc, char **argv) {"
  , "  // Build argv list"
  , "  MiVal *argItems = malloc(argc * sizeof(MiVal));"
  , "  for (int i = 0; i < argc; i++) argItems[i] = mi_string(argv[i]);"
  , "  MiVal argvList = mi_list(argItems, argc);"
  , ""
  , "  // Build world.io record"
  , "  const int io_n = 8;"
  , "  const char **io_names = malloc(io_n * sizeof(const char*));"
  , "  MiVal *io_fields = malloc(io_n * sizeof(MiVal));"
  , "  io_names[0] = \"println\";    io_fields[0] = mi_native(mi_builtin_println);"
  , "  io_names[1] = \"print\";      io_fields[1] = mi_native(mi_builtin_print);"
  , "  io_names[2] = \"readLine\";   io_fields[2] = mi_native(mi_world_readLine);"
  , "  io_names[3] = \"readFile\";   io_fields[3] = mi_native(mi_world_readFile);"
  , "  io_names[4] = \"writeFile\";  io_fields[4] = mi_native(mi_world_writeFile);"
  , "  io_names[5] = \"appendFile\"; io_fields[5] = mi_native(mi_world_appendFile);"
  , "  io_names[6] = \"exists\";     io_fields[6] = mi_native(mi_world_exists);"
  , "  io_names[7] = \"remove\";     io_fields[7] = mi_native(mi_world_remove);"
  , "  MiVal io_rec = mi_make_record(\"_io_\", io_n, io_names, io_fields);"
  , ""
  , "  // Build world.process record"
  , "  const int proc_n = 2;"
  , "  const char **proc_names = malloc(proc_n * sizeof(const char*));"
  , "  MiVal *proc_fields = malloc(proc_n * sizeof(MiVal));"
  , "  proc_names[0] = \"exec\"; proc_fields[0] = mi_native(mi_world_exec);"
  , "  proc_names[1] = \"exit\"; proc_fields[1] = mi_native(mi_world_exit);"
  , "  MiVal proc_rec = mi_make_record(\"_process_\", proc_n, proc_names, proc_fields);"
  , ""
  , "  // Build world record"
  , "  const int world_n = 4;"
  , "  const char **world_names = malloc(world_n * sizeof(const char*));"
  , "  MiVal *world_fields = malloc(world_n * sizeof(MiVal));"
  , "  world_names[0] = \"argv\";    world_fields[0] = argvList;"
  , "  world_names[1] = \"getEnv\";  world_fields[1] = mi_native(mi_world_getEnv);"
  , "  world_names[2] = \"io\";      world_fields[2] = io_rec;"
  , "  world_names[3] = \"process\"; world_fields[3] = proc_rec;"
  , "  return mi_make_record(\"_world_\", world_n, world_names, world_fields);"
  , "}"
  , ""
  ]
