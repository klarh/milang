<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Matthew Spellings" />
  <title>The Milang Programming Language</title>
  <style>
html {
color: #1a1a1a;
background-color: #fdfdfd;
}
body {
margin: 0 auto;
max-width: 36em;
padding-left: 50px;
padding-right: 50px;
padding-top: 50px;
padding-bottom: 50px;
hyphens: auto;
overflow-wrap: break-word;
text-rendering: optimizeLegibility;
font-kerning: normal;
}
@media (max-width: 600px) {
body {
font-size: 0.9em;
padding: 12px;
}
h1 {
font-size: 1.8em;
}
}
@media print {
html {
background-color: white;
}
body {
background-color: transparent;
color: black;
font-size: 12pt;
}
p, h2, h3 {
orphans: 3;
widows: 3;
}
h2, h3, h4 {
page-break-after: avoid;
}
}
p {
margin: 1em 0;
}
a {
color: #1a1a1a;
}
a:visited {
color: #1a1a1a;
}
img {
max-width: 100%;
}
svg {
height: auto;
max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
margin-top: 1.4em;
}
h5, h6 {
font-size: 1em;
font-style: italic;
}
h6 {
font-weight: normal;
}
ol, ul {
padding-left: 1.7em;
margin-top: 1em;
}
li > ol, li > ul {
margin-top: 0;
}
blockquote {
margin: 1em 0 1em 1.7em;
padding-left: 1em;
border-left: 2px solid #e6e6e6;
color: #606060;
}
code {
font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
font-size: 85%;
margin: 0;
hyphens: manual;
}
pre {
margin: 1em 0;
overflow: auto;
}
pre code {
padding: 0;
overflow: visible;
overflow-wrap: normal;
}
.sourceCode {
background-color: transparent;
overflow: visible;
}
hr {
background-color: #1a1a1a;
border: none;
height: 1px;
margin: 1em 0;
}
table {
margin: 1em 0;
border-collapse: collapse;
width: 100%;
overflow-x: auto;
display: block;
font-variant-numeric: lining-nums tabular-nums;
}
table caption {
margin-bottom: 0.75em;
}
tbody {
margin-top: 0.5em;
border-top: 1px solid #1a1a1a;
border-bottom: 1px solid #1a1a1a;
}
th {
border-top: 1px solid #1a1a1a;
padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
margin-bottom: 4em;
text-align: center;
}
#TOC li {
list-style: none;
}
#TOC ul {
padding-left: 1.3em;
}
#TOC > ul {
padding-left: 0;
}
#TOC a:not(:hover) {
text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">The Milang Programming Language</h1>
<p class="author">Matthew Spellings</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__introduction.md__the-milang-programming-language" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__introduction.md__the-milang-programming-language">The
Milang Programming Language</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__installation" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__installation"><span class="toc-section-number">1</span> Installation</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__hello-world" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__hello-world"><span class="toc-section-number">2</span> Hello World</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__how-milang-works" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__how-milang-works"><span class="toc-section-number">3</span> How Milang Works</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__milang-syntax-cheatsheet" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__milang-syntax-cheatsheet"><span class="toc-section-number">4</span> Milang Syntax Cheatsheet</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__values--literals" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__values--literals"><span class="toc-section-number">5</span> Values &amp; Literals</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__functions" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__functions"><span class="toc-section-number">6</span> Functions</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__operators" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__operators"><span class="toc-section-number">7</span> Operators</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__records--adts" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__records--adts"><span class="toc-section-number">8</span> Records &amp; ADTs</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__pattern-matching" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__pattern-matching"><span class="toc-section-number">9</span> Pattern Matching</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__lists" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__lists"><span class="toc-section-number">10</span> Lists</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__scopes--bindings" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__scopes--bindings"><span class="toc-section-number">11</span> Scopes &amp; Bindings</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__imports--modules" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__imports--modules"><span class="toc-section-number">12</span> Imports &amp; Modules</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__io--the-world" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__io--the-world"><span class="toc-section-number">13</span> IO &amp; the World</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__c-ffi" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__c-ffi"><span class="toc-section-number">14</span> C FFI</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__standard-library-reference" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__standard-library-reference"><span class="toc-section-number">15</span> Standard Library Reference</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__type-annotations-" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__type-annotations-"><span class="toc-section-number">16</span> Type Annotations
(<code>::</code>)</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__traits--effects-" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__traits--effects-"><span class="toc-section-number">17</span> Traits &amp; Effects
(<code>:~</code>)</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__documentation-" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__documentation-"><span class="toc-section-number">18</span> Documentation
(<code>:?</code>)</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__parse-decls.md__parse-declarations-" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__parse-decls.md__parse-declarations-"><span class="toc-section-number">19</span> Parse Declarations
(<code>:!</code>)</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__open-function-chaining" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__open-function-chaining"><span class="toc-section-number">20</span> Open Function Chaining</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__partial-evaluation" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__partial-evaluation"><span class="toc-section-number">21</span> Partial Evaluation</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__thunks--laziness" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__thunks--laziness"><span class="toc-section-number">22</span> Thunks &amp; Laziness</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__metaprogramming" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__metaprogramming"><span class="toc-section-number">23</span> Metaprogramming</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__user-defined-operators" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__user-defined-operators"><span class="toc-section-number">24</span> User-Defined Operators</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__security.md__security--capabilities" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__security.md__security--capabilities"><span class="toc-section-number">25</span> Security &amp;
Capabilities</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__tooling.md__tooling--build-notes" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__tooling.md__tooling--build-notes"><span class="toc-section-number">26</span> Tooling &amp; Build Notes</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__repl" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__repl"><span class="toc-section-number">27</span> REPL</a></li>
<li><a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__compiler-modes" id="toc-home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__compiler-modes"><span class="toc-section-number">28</span> Compiler Modes</a></li>
</ul>
</nav>
<h1 class="unnumbered" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__introduction.md__the-milang-programming-language">The
Milang Programming Language</h1>
<p>Milang is a minimalist functional programming language with:</p>
<ul>
<li><strong>Zero keywords</strong> — everything is a function or
operator, including <code>if</code></li>
<li><strong>Haskell-like syntax</strong> — clean, whitespace-sensitive,
expression-oriented</li>
<li><strong>Partial evaluation</strong> as the core compilation model —
the compiler reduces your program as far as possible at compile time,
then emits C code for what remains</li>
<li><strong>Capability-based IO</strong> — side effects flow through an
explicit <code>world</code> value</li>
<li><strong>Five annotation domains</strong> — types (<code>::</code>) ,
traits (<code>:~</code>), docs (<code>:?</code>), parse declarations
(<code>:!</code>), and values (<code>=</code>)</li>
</ul>
<p>Note: the lazy binding operator <code>:=</code> is a variant of the
value domain (it creates a cached thunk) and is not a separate
annotation domain.</p>
<p>Milang is designed around three guiding principles: extreme
simplicity, aggressive compile-time evaluation, and explicit
capabilities for side effects.</p>
<p>There are no special syntactic forms in Milang — control flow,
conditionals, and data construction are expressed with ordinary
functions and operators. This uniform surface makes programs concise and
composable, and helps both authors and tooling reason about code
consistently.</p>
<p>Partial evaluation is the heart of the compiler: any expression that
can be resolved at compile time is evaluated by the compiler itself. The
result is that high-level abstractions often carry zero runtime cost —
configuration, macro-like computation, and many optimizations happen
automatically while compiling into straightforward C.</p>
<p>Milang uses an explicit capability-based IO model: the program entry
point receives a <code>world</code> record that contains sub-records
like <code>io</code> and <code>process</code>. By passing only the
capabilities a function needs, you restrict what it can do. The compiler
targets C and emits code suitable for <code>gcc</code> or
<code>clang</code>, which makes Milang programs portable and fast.</p>
<p>The repository contains focused examples covering language features
referenced throughout this guide.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__introduction.md__quick-example">Quick
Example</h2>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}

area s = s -&gt;
  Circle = 3.14 * s.radius * s.radius
  Rect = s.width * s.height

main world =
  world.io.println (area (Circle 5))
  world.io.println (area (Rect 3 4))
</code></pre>
<pre><code>78.5
12
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__introduction.md__how-it-compiles">How
It Compiles</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> source <span class="at">-</span><span class="op">&gt;</span> parse <span class="at">-</span><span class="op">&gt;</span> import resolution <span class="at">-</span><span class="op">&gt;</span> partial evaluation <span class="at">-</span><span class="op">&gt;</span> C codegen <span class="at">-</span><span class="op">&gt;</span> gcc</span></code></pre></div>
<p>The partial evaluator is the heart of milang: it reduces all
compile-time-known expressions to values, leaving only runtime-dependent
code in the output. This means zero runtime overhead for abstractions
that are fully known at compile time.</p>
<h1 data-number="1" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__installation"><span class="header-section-number">1</span> Installation</h1>
<p>Milang is built from source using the Haskell toolchain and compiles
programs to C via <code>gcc</code>.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__pre-built-binaries">Pre-built
Binaries</h2>
<p>Automated builds for Windows, macOS, and Linux (static) are available
at: <strong><a href="https://github.com/klarh/milang/actions/workflows/build.yml">https://github.com/klarh/milang/actions/workflows/build.yml</a></strong></p>
<p>Download the artifact for your platform from any successful workflow
run — no Haskell toolchain needed.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__prerequisites">Prerequisites</h2>
<p>You need three things installed:</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 51%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr>
<th>Tool</th>
<th>Minimum version</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GHC</strong></td>
<td>9.6+</td>
<td>Haskell compiler (builds the milang compiler itself)</td>
</tr>
<tr>
<td><strong>cabal</strong></td>
<td>3.10+</td>
<td>Haskell build tool</td>
</tr>
<tr>
<td><strong>gcc</strong></td>
<td>any recent</td>
<td>C compiler (milang emits C, then calls gcc to produce binaries)</td>
</tr>
</tbody>
</table>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__ubuntu--debian">Ubuntu
/ Debian</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> apt install ghc cabal-install build-essential</span></code></pre></div>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__arch-linux">Arch
Linux</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> pacman <span class="at">-S</span> ghc cabal-install base-devel</span></code></pre></div>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__macos-homebrew">macOS
(Homebrew)</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">brew</span> install ghc cabal-install gcc</span></code></pre></div>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__building-from-source">Building
from Source</h2>
<p>Clone the repository and build:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone <span class="op">&lt;</span>repository<span class="op">&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> milang</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span></span></code></pre></div>
<p><code>make</code> runs <code>cabal build</code> inside the
<code>core/</code> directory.</p>
<p>If you prefer to do it manually:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> core</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> update</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> build</span></code></pre></div>
<p>For a statically linked compiler build (Linux) using Podman, you can
use the provided Makefile in the core/ directory:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> core</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span> <span class="at">-f</span> Makefile.static</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"># now ./milang is available</span></span></code></pre></div>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__installation.md__verifying-the-installation">Verifying
the Installation</h2>
<p>Start the REPL to confirm everything works:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> repl</span></code></pre></div>
<p>You should see a <code>λ&gt;</code> prompt. Try evaluating an
expression:</p>
<pre class="text"><code>λ&gt; 2 + 3
5
</code></pre>
<p>Press Ctrl-D to exit.</p>
<p>Run the test suite to make sure the compiler is healthy:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span> test</span></code></pre></div>
<p>This compiles and runs every <code>.mi</code> file in the
repository&#39;s test suite. A successful run prints something like
<code>Passed: 60, Failed: 0</code>.</p>
<h1 data-number="2" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__hello-world"><span class="header-section-number">2</span> Hello World</h1>
<p>This guide walks through creating, running, and compiling your first
Milang program and explains common variants useful when learning the
language.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__your-first-program">Your
First Program</h2>
<p>Create a file called hello.mi with this content:</p>
<pre class="milang"><code>main world =
  world.io.println &quot;Hello, Milang!&quot;
</code></pre>
<pre><code>Hello, Milang!
</code></pre>
<p>Run it with the bundled binary:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> run hello.mi</span></code></pre></div>
<p>Expected output:</p>
<pre><code>Hello, Milang!
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__what-main-and-world-mean">What
<code>main</code> and <code>world</code> mean</h3>
<ul>
<li><code>main</code> is the program entry point by convention (not a
language keyword).</li>
<li><code>world</code> is an explicit record that carries runtime
capabilities: <code>world.io</code> (console and file IO),
<code>world.process</code> (exec/exit), <code>world.argv</code>, and
helpers like <code>getEnv</code>.</li>
<li>Only code that receives the appropriate part of <code>world</code>
can perform the corresponding effects — pass only what you need to
follow the principle of least privilege.</li>
</ul>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__printing-and-helpers">Printing
and Helpers</h2>
<p><code>println</code> appends a newline; <code>print</code> does not.
Prefer small helpers that accept only the sub-record they need:</p>
<pre class="milang"><code>greet io name = io.println (&quot;Hello, &quot; + name + &quot;!&quot;)

main world =
  greet world.io &quot;Alice&quot;
</code></pre>
<pre><code>Hello, Alice!
</code></pre>
<p>This makes <code>greet</code> unable to access process or filesystem
capabilities.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__handling-command-line-arguments">Handling
Command-Line Arguments</h2>
<p>A more advanced &quot;Hello World&quot; might greet someone by name, using
command-line arguments. The <code>world.argv</code> list contains the
arguments. The following example, which you can save as
<code>hello_argv.mi</code>, demonstrates this. It uses a helper function
to safely get an argument or fall back to a default value.</p>
<pre class="milang"><code>-- main entrypoint
main world =
  name = fromMaybe &quot;World&quot; (at&#39; 1 world.argv)
  world.io.println (&quot;Hello, &quot; + name + &quot;!&quot;)
</code></pre>
<pre><code>Hello, World!
</code></pre>
<p>Run this from your terminal:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># With no arguments</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> run hello_argv.mi</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Expected output: Hello, World!</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co"># With an argument</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> run hello_argv.mi <span class="st">&quot;Universe&quot;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Expected output: Hello, Universe!</span></span></code></pre></div>
<p>This example shows several concepts:</p>
<ul>
<li><code>world.argv</code>: A list of strings from the command
line.</li>
<li><code>at&#39;</code>: A prelude function to safely get an element from a
list by index. It returns a <code>Maybe</code> value. (<code>at&#39;</code>
takes index first; <code>at</code> takes list first for use as an
operator: <code>xs `at` 1</code>).</li>
<li><code>fromMaybe</code>: A prelude function that unwraps a
<code>Maybe</code>, returning a default value if
<code>Nothing</code>.</li>
</ul>
<p>This pattern of using helpers to safely extract information is common
in Milang.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__script-mode-quick-experiments">Script
Mode (quick experiments)</h2>
<p>When a file does not define <code>main</code> that takes a parameter,
<code>milang run</code> executes in script mode: every top-level binding
is evaluated and printed. This is ideal for short tests and REPL-style
exploration.</p>
<pre class="milang"><code>x = 6 * 7
y = x + 1
</code></pre>
<pre><code>x = 42
y = 43
</code></pre>
<p>Script-mode output prints name/value pairs for top-level bindings
(prelude/internal bindings are hidden).</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__printing-non-strings-and-maybe-values">Printing
non-strings and Maybe values</h2>
<p>Use <code>toString</code> to render non-string values. Many standard
library functions return <code>Maybe</code> to handle operations that
might fail, like converting a string to a number. For example,
<code>toInt</code> returns <code>Just(number)</code> on success and
<code>Nothing</code> on failure.</p>
<p>Use <code>toString</code> to safely print these <code>Maybe</code>
values.</p>
<pre class="milang"><code>main world =
  world.io.println (toString (toInt &quot;42&quot;))
  world.io.println (toString (toInt &quot;abc&quot;))
</code></pre>
<pre><code>Just(42)
Nothing
</code></pre>
<p>This will print:</p>
<pre class="text"><code>Just(42)
Nothing
</code></pre>
<p>The <code>Maybe</code> type is how Milang handles optional values,
avoiding nulls and making error handling more explicit. You can use <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__pattern-matching">pattern
matching</a> to safely unwrap these values.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__compiling-to-c">Compiling
to C</h2>
<p>Emit the generated C and compile it:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> compile hello.mi hello.c</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> hello.c <span class="at">-o</span> hello</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ex">./hello</span></span></code></pre></div>
<p>The C file embeds the milang runtime; you only need a standard C
toolchain.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__using-the-repl">Using
the REPL</h2>
<p>Start the REPL for interactive experimentation:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> repl</span></code></pre></div>
<p>Example session:</p>
<pre class="text"><code>&gt; 2 + 3
5
&gt; f x = x * x
&gt; f 8
64
&gt; map f [1, 2, 3, 4]
[1, 4, 9, 16]
</code></pre>
<p>Bindings persist across lines; you may rethink and refine definitions
live. Many common functions like <code>map</code>, <code>filter</code>,
and <code>fold</code> are available automatically because they are part
of the prelude.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__hello-world.md__next-steps">Next
Steps</h2>
<ul>
<li>Read the full <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__milang-syntax-cheatsheet">syntax
cheatsheet</a>.</li>
<li>Inspect reduction with <code>./milang reduce</code> (see <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__partial-evaluation">Partial
Evaluation</a>).</li>
<li>Try the larger examples in the repository root.</li>
</ul>
<h1 data-number="3" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__how-milang-works"><span class="header-section-number">3</span> How Milang Works</h1>
<p>Milang&#39;s compilation pipeline has four stages:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">source.mi</span> <span class="at">-</span><span class="op">&gt;</span> Parser <span class="at">-</span><span class="op">&gt;</span> Import Resolution <span class="at">-</span><span class="op">&gt;</span> Partial Evaluator <span class="at">-</span><span class="op">&gt;</span> C Codegen <span class="at">-</span><span class="op">&gt;</span> gcc</span></code></pre></div>
<p>Each stage is a pure transformation of the AST, except for import
resolution (which reads files and URLs) and the final gcc
invocation.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__1-parser">1.
Parser</h2>
<p>The parser is indentation-sensitive — nested blocks are determined by
whitespace, similar to Haskell or Python.</p>
<p>There are <strong>zero keywords</strong> in milang. Everything that
looks like a keyword — <code>if</code>, <code>import</code>,
<code>true</code>, <code>false</code> — is actually a function or value
defined in the prelude. The parser only needs to recognize:</p>
<ul>
<li><strong>Bindings</strong> across five annotation domains:
<code>=</code> (value), <code>::</code> (type), <code>:~</code>
(traits), <code>:?</code> (docs), <code>:!</code> (parse)</li>
<li><strong>Expressions</strong>: literals, application, operators,
lambdas, records, lists, pattern match (<code>-&gt;</code>)</li>
<li><strong>Operators</strong>: parsed with configurable precedence
(<code>:!</code> declarations can define new ones)</li>
</ul>
<p>The output is a single <code>Expr</code> AST type with variants like
<code>IntLit</code>, <code>App</code>, <code>Lam</code>,
<code>Namespace</code>, <code>Record</code>, <code>Match</code>, and so
on.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__2-import-resolution">2.
Import Resolution</h2>
<p>When the parser encounters <code>import &quot;path.mi&quot;</code>, the import
resolver:</p>
<ol>
<li><strong>Reads the file</strong> (local path or URL)</li>
<li><strong>Parses it</strong> into an AST</li>
<li><strong>Recursively resolves</strong> its imports</li>
<li><strong>Returns a record</strong> of the module&#39;s exported
bindings</li>
</ol>
<p>Import types:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Syntax</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>import &quot;lib/utils.mi&quot;</code></td>
<td>Local file (relative to importing file)</td>
</tr>
<tr>
<td><code>import &quot;https://example.com/lib.mi&quot;</code></td>
<td>URL (downloaded and cached)</td>
</tr>
<tr>
<td><code>import &quot;/usr/include/math.h&quot;</code></td>
<td>C header (extracts function signatures for FFI)</td>
</tr>
</tbody>
</table>
<p><strong>URL security:</strong> URL imports must be pinned with a
SHA-256 hash using <code>import&#39;</code> and a hash record. The
<code>milang pin</code> command fetches imports and writes the hashes
back into your source file. The hash covers the content of the import
and all of its transitive sub-imports (a Merkle hash), so any tampering
is detected.</p>
<p><strong>Circular imports</strong> are handled by returning only the
non-import bindings from the cycle and marking the recursive reference
as a lazy thunk.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__3-partial-evaluator">3.
Partial Evaluator</h2>
<p>The partial evaluator is the heart of the compiler. It walks the AST
and <strong>reduces every expression it can</strong> given the values it
knows at compile time.</p>
<p>Consider:</p>
<pre class="milang"><code>double x = x * 2
y = double 21
</code></pre>
<pre><code>double = &lt;closure&gt;
y = 42
</code></pre>
<p>The partial evaluator sees that <code>double</code> is fully known
and <code>21</code> is a literal, so it evaluates <code>double 21</code>
at compile time. The result in the reduced AST is simply
<code>y = 42</code> — the function call has been eliminated
entirely.</p>
<p>Key techniques:</p>
<ul>
<li><strong>Strongly Connected Component (SCC) analysis</strong> —
bindings are sorted by dependency so each group can be reduced in
order.</li>
<li><strong>Depth-limited recursion</strong> — recursive functions are
unrolled a fixed number of times. If the result converges (reaches a
base case), it becomes a compile-time constant. Otherwise, the function
is left as runtime code.</li>
<li><strong>Environment threading</strong> — the evaluator carries a map
of known bindings. When a binding&#39;s value is fully determined, it&#39;s
substituted into all uses.</li>
</ul>
<p>The partial evaluator <strong>is</strong> the optimizer. There is no
separate optimization pass. Any abstraction that is fully known at
compile time — constants, configuration, helper functions applied to
literals, record construction — is resolved to a value before code
generation.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__4-c-code-generation">4.
C Code Generation</h2>
<p>The code generator takes the reduced AST and emits a single,
self-contained C file. This file includes:</p>
<ul>
<li><strong>An embedded runtime</strong> — an arena allocator, a tagged
union value type (<code>MiVal</code>), environment chains, and built-in
functions.</li>
<li><strong>Arena allocation</strong> — all milang values are allocated
from 1 MB arena blocks with 8-byte alignment. There is no garbage
collector; arenas are freed in bulk.</li>
<li><strong>Tagged unions</strong> — every runtime value is a
<code>MiVal</code> with a <code>tag</code> (<code>MI_INT</code>,
<code>MI_FLOAT</code>, <code>MI_STRING</code>, <code>MI_CLOSURE</code>,
<code>MI_RECORD</code>, etc.) and a payload.</li>
<li><strong>Tail-call optimization</strong> — <code>tail</code> calls
are compiled to <code>goto</code> jumps, so recursive functions run in
constant stack space.</li>
<li><strong>Closures</strong> — functions that capture variables are
represented as a code pointer plus an environment chain of
bindings.</li>
</ul>
<p>The generated C compiles with <code>gcc</code> (or
<code>clang</code>) and links against the standard C library:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> output.c <span class="at">-o</span> program</span></code></pre></div>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__the-key-insight">The
Key Insight</h2>
<p>Because the partial evaluator runs at compile time,
<strong>high-level abstractions often have zero runtime cost</strong>. A
chain of helper functions, a configuration record, a computed lookup
table — if the inputs are known at compile time, none of that code
exists in the generated binary. Only expressions that depend on runtime
values (IO, user input, command-line arguments) survive into the emitted
C.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__how-it-works.md__debugging-the-pipeline">Debugging
the Pipeline</h2>
<p>Two compiler commands let you inspect intermediate stages:</p>
<ul>
<li><strong><code>milang dump file.mi</code></strong> — shows the parsed
AST before import resolution. Useful for checking how the parser
interpreted your syntax.</li>
<li><strong><code>milang reduce file.mi</code></strong> — shows the AST
after partial evaluation. This is what the code generator sees. Use it
to verify that compile-time computation happened as expected.</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> dump myfile.mi    <span class="co"># parsed AST</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> reduce myfile.mi  <span class="co"># after partial evaluation</span></span></code></pre></div>
<h1 data-number="4" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__milang-syntax-cheatsheet"><span class="header-section-number">4</span> Milang Syntax Cheatsheet</h1>
<p>Milang is a functional language with <strong>zero keywords</strong>,
Haskell-like syntax, and partial evaluation as the core compilation
model. Everything is an expression.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__literals">Literals</h2>
<pre class="text"><code>42              -- integer
3.14            -- float
&quot;hello&quot;         -- string (supports \n \t \\ \&quot;)
&quot;&quot;&quot;
  multi-line    -- triple-quoted string (Swift-style margin stripping)
  string        -- closing &quot;&quot;&quot; indentation defines the margin
  &quot;&quot;&quot;
[]              -- empty list (Nil record)
[1, 2, 3]      -- list literal (desugars to Cons/Nil chain)
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__bindings">Bindings</h2>
<pre class="milang"><code>x = 42                    -- value binding
f x y = x + y             -- function binding (params before =)
lazy := expensive_calc    -- lazy binding (thunk, evaluated on first use)
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__functions--application">Functions
&amp; Application</h2>
<pre class="milang"><code>f x y = x + y             -- define: name params = body
f 3 4                     -- apply: juxtaposition (left-associative)
(\x -&gt; x + 1)             -- lambda
(\x y -&gt; x + y)           -- multi-param lambda
f 3 |&gt; g                  -- pipe: g (f 3)
f &gt;&gt; g                    -- compose left-to-right: \x -&gt; g (f x)
f &lt;&lt; g                    -- compose right-to-left: \x -&gt; f (g x)
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__operators">Operators</h2>
<p>All operators are just functions. Standard arithmetic, comparison,
logical:</p>
<pre class="text"><code>+ - * / % **              -- arithmetic (** is power)
== /= &lt; &gt; &lt;= &gt;=           -- comparison
&amp;&amp; ||                     -- logical (short-circuit)
not x                     -- logical negation (function, not operator)
+ `+`                       -- string concat (use `+` for both numeric and string)
:                         -- cons (right-assoc): 1 : 2 : [] = [1, 2]
</code></pre>
<p>Operators as functions and functions as operators:</p>
<pre class="milang"><code>(+) 3 4                   -- operator in prefix: 7
3 `add` 4                 -- function in infix (backtick syntax)
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__records">Records</h2>
<pre class="text"><code>-- Anonymous record
point = {x = 3; y = 4}

-- Field access
point.x                       -- 3

-- Positional access (by declaration order)
point._0                      -- 3 (first field)

-- Record update
point2 = point &lt;- {x = 10}      -- {x = 10, y = 4}

-- Nested access
world.io.println              -- chained field access

-- Destructuring
{x; y} = point               -- binds x=3, y=4
{myX = x; myY = y} = point   -- binds myX=3, myY=4

-- Parsing gotcha
-- When passing a record literal directly as an argument you may need to parenthesize
-- the literal or bind it to a name to avoid parse ambiguity. For example:
--   -- may need parentheses
--   getField ({a = 1}) &quot;a&quot;
--   -- or bind first
--   r = {a = 1}
--   getField r &quot;a&quot;
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__adts-algebraic-data-types">ADTs
(Algebraic Data Types)</h2>
<p>Uppercase bindings with braces declare tagged constructors:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}

-- Creates constructors:
c = Circle 5              -- {radius = 5} tagged &quot;Circle&quot;
r = Rect 3 4              -- {width = 3, height = 4} tagged &quot;Rect&quot;

-- Named fields also work:
Shape = {Circle {radius}; Rect {width; height}}
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__pattern-matching">Pattern
Matching</h2>
<p>The <code>-&gt;</code> operator introduces match alternatives:</p>
<pre class="text"><code>-- Inline alternatives (separated by ;)
f x = x -&gt; 0 = &quot;zero&quot;; 1 = &quot;one&quot;; _ = &quot;other&quot;

-- Indented alternatives
f x = x -&gt;
  0 = &quot;zero&quot;
  1 = &quot;one&quot;
  _ = &quot;other&quot;

-- Pattern types
42                        -- literal match
x                         -- variable (binds anything)
_                         -- wildcard (match, don&#39;t bind)
Circle                    -- constructor tag match
Rect                      -- constructor tag match (fields accessible via .field)
[a, b, c]                 -- list pattern (exact length)
[first, ...rest]          -- list pattern with spread

-- Guards (| condition = body)
abs x = x -&gt;
  n | n &gt;= 0 = n
  n = 0 - n

-- Pattern matching in case expressions
area s = s -&gt;
  Circle = 3.14 * s.radius * s.radius
  Rect = s.width * s.height
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__scopes--multi-line-bodies">Scopes
&amp; Multi-line Bodies</h2>
<p>Indented lines under a binding form a scope:</p>
<pre class="milang"><code>-- With explicit body expression (body = the expression after =)
compute x = result
  doubled = x * 2
  result = doubled + 1
-- Returns: value of `result` (15 when x=7)

-- Without body expression (scope returns implicit record)
makeVec x y =
  dx = x ** 2
  dy = y ** 2
  sumSquares = dx + dy
-- Returns: {dx = 49, dy = 9, sumSquares = 58}

-- Bare expressions in scopes evaluate for effect, not included in record
main world =
  world.io.println &quot;hello&quot;       -- effect: prints, result discarded
  world.io.println &quot;world&quot;       -- effect: prints, result discarded
</code></pre>
<p>Inline scopes use braces:</p>
<pre class="milang"><code>f x = result { doubled = x * 2; result = doubled + 1 }
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__io--the-world">IO
&amp; the World</h2>
<p>IO uses capability-based design. <code>main</code> receives
<code>world</code>:</p>
<pre class="milang"><code>main world =
  world.io.println &quot;hello&quot;              -- print line
  world.io.print &quot;no newline&quot;           -- print without newline
  line = world.io.readLine              -- read line from stdin
  contents = world.fs.read.file &quot;f&quot;     -- read file
  world.fs.write.file &quot;f&quot; &quot;data&quot;        -- write file
  world.fs.write.append &quot;f&quot; &quot;more&quot;      -- append to file
  exists = world.fs.read.exists &quot;f&quot;     -- check file exists
  world.fs.write.remove &quot;f&quot;             -- delete file
  result = world.process.exec &quot;ls&quot;      -- run shell command
  world.process.exit 1                  -- exit with code
  args = world.argv                     -- command-line args (list)
  val = world.getEnv &quot;PATH&quot;             -- environment variable
  0

-- Pass restricted capabilities to helpers
greet io = io.println &quot;hello&quot;
main world = greet world.io          -- only give IO, not process/fs
</code></pre>
<pre><code>hello
</code></pre>
<p><code>main</code>&#39;s return value is the process exit code (int -&gt;
exit code, non-int -&gt; 0).</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__imports">Imports</h2>
<pre class="text"><code>-- Local file import (result is a record of all top-level bindings)
math = import &quot;lib/math.mi&quot;
x = math.square 5

-- URL import (cached locally)
lib = import &quot;https://example.com/lib.mi&quot;

-- URL import with sha256 pinning (required for reproducibility)
lib = import&#39; &quot;https://example.com/lib.mi&quot; ({sha256 = &quot;a1b2c3...&quot;})

-- C header import (auto-parses function signatures)
m = import &quot;/usr/include/math.h&quot;
x = m.sin 1.0

-- C header with source file linking
lib = import&#39; &quot;mylib.h&quot; ({src = &quot;mylib.c&quot;})

-- C header with extended options
lib = import&#39; &quot;mylib.h&quot; ({
  sources = [&quot;a.c&quot;, &quot;b.c&quot;]
  flags = &quot;-O2&quot;
  include = &quot;include&quot;
  pkg = &quot;libpng&quot;
})
</code></pre>
<p>Binding names are always lowercase. Uppercase names are reserved for
type declarations (union types, record constructors, type
annotations).</p>
<p>Use <code>milang pin &lt;file&gt;</code> to auto-discover URL imports
and add sha256 hashes.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__annotation-domains">Annotation
Domains</h2>
<p>Milang has five binding domains, each with its own operator:</p>
<pre class="milang"><code>-- Value domain (=) — what it computes
add a b = a + b

-- Type domain (::) — structural type annotation
add :: Num : Num : Num

-- Sized numeric types: Int&#39;, UInt&#39;, Float&#39; take a bit width
-- Prelude aliases: Int = Int&#39; 64, UInt = UInt&#39; 64, Float = Float&#39; 64, Byte = UInt&#39; 8
add8 :: Int&#39; 8 : Int&#39; 8 : Int&#39; 8

-- Traits domain (:~) — computational attributes / effect sets
add :~ pure                          -- pure = [] (no effects)
greet :~ [console]                   -- needs console capability
server :~ [console, fs.read, fs.write]

-- Documentation domain (:?) — human-readable docs
add :? &quot;Add two numbers&quot;
add :? {summary = &quot;Add two numbers&quot;; params = {a = &quot;First&quot;; b = &quot;Second&quot;}}
add :? &quot;&quot;&quot;
  Add two numbers together.
  Returns their sum.
  &quot;&quot;&quot;

-- Parse domain (:!) — operator precedence/associativity
(+) :! {prec = 6; assoc = Left}

-- All domains can coexist on one binding:
distance :? &quot;Euclidean distance&quot;
distance :: Point : Point : Num
distance :~ pure
distance p1 p2 = (p2.x - p1.x)**2 + (p2.y - p1.y)**2
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__thunks--laziness">Thunks
&amp; Laziness</h2>
<pre class="milang"><code>~expr                   -- thunk: delays evaluation
x := expensive          -- lazy binding: creates thunk, evaluates once on use
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__metaprogramming">Metaprogramming</h2>
<pre class="milang"><code>#expr                   -- quote: capture AST as a record
$expr                   -- splice: evaluate quoted AST back to code
f #param = $param       -- auto-quote param: compiler quotes arg at call site
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__comments">Comments</h2>
<pre class="text"><code>-- line comment
/* block comment (nestable) */
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__built-in-functions">Built-in
Functions</h2>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__core">Core</h3>
<ul>
<li><code>if cond then else</code> — conditional (auto-quotes branches
via <code>#</code>-params)</li>
<li><code>len xs</code> — length of string or list</li>
<li><code>toString x</code> — convert to string</li>
<li><code>toInt s</code> — parse string to int; returns
<code>Just</code> on success, <code>Nothing</code> on failure</li>
<li><code>toFloat s</code> — parse string to float; returns
<code>Just</code> on success, <code>Nothing</code> on failure</li>
</ul>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__string">String</h3>
<ul>
<li><code>charAt i s</code> — character at index; returns
<code>Just</code> character when index valid, otherwise
<code>Nothing</code></li>
<li><code>slice start end s</code> — substring</li>
<li><code>indexOf needle haystack</code> — find substring (-1 if not
found)</li>
<li><code>split sep s</code> — split string by separator</li>
<li><code>trim s</code> — strip whitespace</li>
<li><code>toUpper s</code> / <code>toLower s</code> — case
conversion</li>
<li><code>replace old new s</code> — string replacement</li>
</ul>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__list-prelude">List
(prelude)</h3>
<ul>
<li><code>head xs</code> / <code>tail xs</code> / <code>last xs</code> /
<code>init xs</code> — return <code>Maybe</code> (<code>Just</code>
value or <code>Nothing</code>)</li>
<li><code>map f xs</code> / <code>filter f xs</code> /
<code>fold f acc xs</code></li>
<li><code>concat xs ys</code> / <code>push xs x</code> /
<code>reverse xs</code></li>
<li><code>take n xs</code> / <code>drop n xs</code> /
<code>slice start end xs</code></li>
<li><code>zip xs ys</code> / <code>enumerate xs</code> /
<code>range start end</code></li>
<li><code>sum xs</code> / <code>product xs</code> /
<code>join sep xs</code></li>
<li><code>any f xs</code> / <code>all f xs</code> /
<code>contains x xs</code></li>
<li><code>at lst i</code> / <code>at&#39; i lst</code> — element at index
(returns <code>Maybe</code>)</li>
<li><code>sort xs</code> / <code>sortBy f xs</code></li>
</ul>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__record-introspection">Record
introspection</h3>
<ul>
<li><code>fields r</code> — list of <code>{name, value}</code>
records</li>
<li><code>fieldNames r</code> — list of field name strings</li>
<li><code>tag r</code> — constructor <code>tag</code> string (or
&quot;&quot;)</li>
<li><code>getField r name</code> — dynamic field access; returns
<code>Just value</code> if present, otherwise <code>Nothing</code>.</li>
<li><code>setField r name val</code> — return new record with field
set</li>
</ul>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__utility">Utility</h3>
<ul>
<li><code>id x</code> / <code>const x y</code> /
<code>flip f x y</code></li>
<li><code>abs x</code> / <code>min a b</code> /
<code>max a b</code></li>
</ul>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__cheatsheet.md__compiler-modes">Compiler
Modes</h2>
<div class="sourceCode" id="cb52"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> run file.mi          <span class="co"># compile + run</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> compile file.mi o.c  <span class="co"># emit C code</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> dump file.mi         <span class="co"># show parsed AST</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> reduce file.mi       <span class="co"># show partially-evaluated AST</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> repl                 <span class="co"># interactive REPL</span></span></code></pre></div>
<h1 data-number="5" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__values--literals"><span class="header-section-number">5</span> Values &amp; Literals</h1>
<p>This chapter covers the literal forms you can write directly in
source code.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__integers">Integers</h2>
<p>Integer literals are written as decimal digits. Negative integers use
a leading minus sign attached to the literal. At compile time integers
have arbitrary precision; at runtime they default to
<code>int64_t</code> (signed 64-bit).</p>
<p>The type system supports sized integers via <code>Int&#39;</code>
(signed) and <code>UInt&#39;</code> (unsigned) type constructors that take a
bit width: <code>Int&#39; 8</code>, <code>Int&#39; 32</code>,
<code>UInt&#39; 64</code>, etc. The prelude provides aliases:
<code>Int = Int&#39; 64</code>, <code>UInt = UInt&#39; 64</code>,
<code>Byte = UInt&#39; 8</code>.</p>
<pre class="milang"><code>small = 42
zero = 0
negative = -3
big = 2 ** 32
</code></pre>
<pre><code>small = 42
zero = 0
negative = -3
big = 4294967296
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__floats">Floats</h2>
<p>Floating-point literals require digits on both sides of the decimal
point. They default to C <code>double</code> (64-bit). Negative floats
use a leading minus sign. Sized floats are available via
<code>Float&#39;</code>: <code>Float&#39; 32</code> for single precision,
<code>Float&#39; 64</code> for double precision. The prelude alias
<code>Float = Float&#39; 64</code>.</p>
<pre class="milang"><code>pi = 3.14
half = 0.5
neg = -2.718
</code></pre>
<pre><code>pi = 3.14
half = 0.5
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__strings">Strings</h2>
<p>Strings are double-quoted and support the escape sequences
<code>\n</code>, <code>\t</code>, <code>\\</code>, and
<code>\&quot;</code>.</p>
<pre class="milang"><code>greeting = &quot;hello, world&quot;
escaped = &quot;line one\nline two&quot;
length = len greeting
</code></pre>
<pre><code>greeting = hello, world
escaped = line one
line two
length = 12
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__triple-quoted-strings">Triple-Quoted
Strings</h3>
<p>Triple-quoted strings span multiple lines with automatic margin
stripping (Swift-style). The indentation of the closing <code>&quot;&quot;&quot;</code>
defines the margin — everything to the left of that column is
removed.</p>
<pre class="milang"><code>msg = &quot;&quot;&quot;
  Hello, world!
    indented line
  &quot;&quot;&quot;
</code></pre>
<pre><code>msg = Hello, world!
  indented line
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__booleans">Booleans</h2>
<p>There is no dedicated boolean type. Milang uses integers:
<code>1</code> is true, <code>0</code> is false. Comparison and logical
operators return <code>1</code> or <code>0</code>, and <code>if</code>
treats <code>0</code> as false and any non-zero value as true.</p>
<pre class="milang"><code>yes = 1
no = 0
check = 3 &gt; 2
</code></pre>
<pre><code>yes = 1
no = 0
check = 1
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__lists">Lists</h2>
<p>Lists are linked-list cons cells declared in the prelude as
<code>List = {Nil; Cons head tail}</code>. The literal syntax
<code>[1, 2, 3]</code> desugars into a chain of
<code>Cons</code>/<code>Nil</code> records. The cons operator
<code>:</code> is right-associative.</p>
<pre class="milang"><code>nums = [1, 2, 3]
empty = []
consed = 10 : 20 : 30 : []
</code></pre>
<pre><code>nums = [1, 2, 3]
empty = []
consed = [10, 20, 30]
</code></pre>
<p>See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__lists">Lists</a>
chapter for the full prelude API.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__records">Records</h2>
<p>A record is a set of named <code>fields</code> enclosed in braces and
separated by <code>;</code> or newlines.</p>
<pre class="milang"><code>point = {x = 3; y = 4}
access = point.x + point.y
</code></pre>
<pre><code>point =  {x = 3, y = 4}
access = 7
</code></pre>
<p>See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__records--adts">Records
&amp; ADTs</a> chapter for updates, destructuring, and algebraic data
types.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__constructors">Constructors</h2>
<p>An uppercase name applied to arguments creates a tagged record. Tags
are introduced by ADT declarations or used ad-hoc.</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}
c = Circle 5
r = Rect 3 4
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
c = Circle {radius = 5}
r = Rect {width = 3, height = 4}
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__values.md__functions-as-values">Functions
as Values</h2>
<p>Functions are first-class values. They can be bound to names, passed
as arguments, and returned from other functions. A function that has not
received all of its arguments displays as
<code>&lt;closure&gt;</code>.</p>
<pre class="milang"><code>add x y = x + y
inc = add 1
result = inc 10
</code></pre>
<pre><code>add = &lt;closure&gt;
inc = &lt;closure&gt;
result = 11
</code></pre>
<p>See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__functions">Functions</a>
chapter for lambdas, pipes, and more.</p>
<h1 data-number="6" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__functions"><span class="header-section-number">6</span> Functions</h1>
<p>Functions are defined with a name, parameters, <code>=</code>, and a
body. All functions are first-class, automatically curried, and can be
used anywhere a value is expected.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__definition">Definition</h2>
<p>A function binding lists its parameters before <code>=</code>. The
body is a single expression or an indented scope.</p>
<pre class="milang"><code>add x y = x + y
result = add 3 4
</code></pre>
<pre><code>add = &lt;closure&gt;
result = 7
</code></pre>
<p>When the body needs local bindings, indent them under an explicit
result expression:</p>
<pre class="milang"><code>distance x1 y1 x2 y2 = result
  dx = (x2 - x1) ** 2
  dy = (y2 - y1) ** 2
  result = dx + dy
a = distance 0 0 3 4
</code></pre>
<pre><code>distance = &lt;closure&gt;
a = 25
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__application">Application</h2>
<p>Function application is juxtaposition (space-separated), and it is
left-associative: <code>f a b</code> means <code>(f a) b</code>.</p>
<pre class="milang"><code>add 3 4          -- 7
(add 3) 4        -- same thing
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__lambdas">Lambdas</h2>
<p>Anonymous functions use <code>\params -&gt; body</code>.</p>
<pre class="milang"><code>double = \x -&gt; x * 2
add = \x y -&gt; x + y
a = double 5
b = add 3 4
</code></pre>
<pre><code>double = &lt;closure&gt;
add = &lt;closure&gt;
a = 10
b = 7
</code></pre>
<p>Lambdas are ordinary values and appear frequently as arguments to
higher-order functions.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__currying--partial-application">Currying
&amp; Partial Application</h2>
<p>Every function is automatically curried. Supplying fewer arguments
than a function expects returns a new function that waits for the
remaining ones.</p>
<pre class="milang"><code>add x y = x + y
add5 = add 5
result = add5 10
</code></pre>
<pre><code>add = &lt;closure&gt;
add5 = &lt;closure&gt;
result = 15
</code></pre>
<p>This makes it natural to build specialised functions on the fly:</p>
<pre class="milang"><code>doubled = map (\x -&gt; x * 2) [1, 2, 3, 4]
evens = filter (\x -&gt; x % 2 == 0) [1, 2, 3, 4, 5, 6]
total = fold (+) 0 [1, 2, 3, 4, 5]
</code></pre>
<pre><code>doubled = [2, 4, 6, 8]
evens = [2, 4, 6]
total = 15
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__pipes--composition">Pipes
&amp; Composition</h2>
<p>The pipe operator <code>|&gt;</code> passes a value as the
<code>last</code> argument to a function, reading left-to-right:</p>
<pre class="milang"><code>result = [1, 2, 3, 4, 5] \
  |&gt; map (\x -&gt; x * 2) \
  |&gt; filter (\x -&gt; x &gt; 4) \
  |&gt; sum
</code></pre>
<pre><code>result = 24
</code></pre>
<p>Composition operators combine functions without naming an
intermediate value. <code>&gt;&gt;</code> composes left-to-right and
<code>&lt;&lt;</code> composes right-to-left:</p>
<pre class="milang"><code>double x = x * 2
inc x = x + 1
double_then_inc = double &gt;&gt; inc
inc_then_double = inc &gt;&gt; double
a = double_then_inc 5
b = inc_then_double 5
</code></pre>
<pre><code>double = &lt;closure&gt;
inc = &lt;closure&gt;
double_then_inc = &lt;closure&gt;
inc_then_double = &lt;closure&gt;
a = 11
b = 12
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__recursion--tail-call-optimisation">Recursion
&amp; Tail-Call Optimisation</h2>
<p>Functions can reference themselves by name. Milang detects self-calls
(and mutual calls) in <code>tail</code> position and compiles them with
goto-based trampolining, so they run in constant stack space.</p>
<pre class="milang"><code>factorial n = if (n == 0) 1 (n * factorial (n - 1))
result = factorial 10
</code></pre>
<pre><code>factorial = &lt;closure&gt;
result = 3628800
</code></pre>
<p>A <code>tail</code>-recursive accumulator style avoids building up a
chain of multiplications:</p>
<pre class="milang"><code>fac_acc acc n = if (n == 0) acc (fac_acc (acc * n) (n - 1))
result = fac_acc 1 20
</code></pre>
<pre><code>fac_acc = &lt;closure&gt;
result = 2432902008176640000
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__higher-order-functions">Higher-Order
Functions</h2>
<p>A higher-order function accepts or returns another function.</p>
<pre class="milang"><code>twice f x = f (f x)
inc x = x + 1
a = twice inc 3
b = twice (\x -&gt; x * 2) 3
</code></pre>
<pre><code>twice = &lt;closure&gt;
inc = &lt;closure&gt;
a = 5
b = 12
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__functions.md__if-is-a-function"><code>if</code>
Is a Function</h2>
<p>Milang has zero keywords. <code>if</code> is an ordinary user-defined
function in the prelude. It uses <strong>auto-quote parameters</strong>
(<code>#param</code>) so the compiler automatically delays evaluation of
each branch — only the chosen one runs:</p>
<pre class="milang"><code>if (x &gt; 0) &quot;positive&quot; &quot;non-positive&quot;
</code></pre>
<p>No special syntax is needed at the call site. The <code>if</code>
definition uses <code>#t</code> and <code>#e</code> parameters which
trigger automatic quoting; inside the body, <code>$t</code> and
<code>$e</code> splice (evaluate) only the selected branch. See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__metaprogramming">Metaprogramming</a>
chapter for details on auto-quote params, and <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__thunks--laziness">Thunks
&amp; Laziness</a> for the older <code>~</code> approach.</p>
<h1 data-number="7" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__operators"><span class="header-section-number">7</span> Operators</h1>
<p>Operators in milang are ordinary functions with special syntax. Every
operator can be used in prefix form by wrapping it in parentheses, and
any function can be used infix with backtick syntax.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__arithmetic">Arithmetic</h2>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>Addition (also string concatenation)</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Subtraction</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiplication</td>
</tr>
<tr>
<td><code>/</code></td>
<td>Division (integer for ints, float for floats)</td>
</tr>
<tr>
<td><code>%</code></td>
<td>Modulo (integers only)</td>
</tr>
<tr>
<td><code>**</code></td>
<td>Exponentiation (integer exponent)</td>
</tr>
</tbody>
</table>
<pre class="milang"><code>a = 2 + 3
b = 10 - 4
c = 3 * 7
d = 10 / 3
e = 10 % 3
f = 2 ** 10
</code></pre>
<pre><code>a = 5
b = 6
c = 21
d = 3
e = 1
f = 1024
</code></pre>
<p>Float division produces a decimal result:</p>
<pre class="milang"><code>a = 7.0 / 2.0
b = 3.14 * 2.0
</code></pre>
<pre><code>a = 3.5
b = 6.28
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__comparison">Comparison</h2>
<p>Comparison operators return <code>1</code> (true) or <code>0</code>
(false). <code>==</code> and <code>/=</code> work structurally on
records, lists, and strings.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>Equal</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>Not equal</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Less than</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Greater than</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Less than or equal</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Greater than or equal</td>
</tr>
</tbody>
</table>
<pre class="milang"><code>a = 3 == 3
b = 3 /= 4
c = 5 &gt; 2
d = [1, 2] == [1, 2]
e = &quot;hello&quot; == &quot;hello&quot;
</code></pre>
<pre><code>a = 1
b = 1
c = 1
d = 1
e = 1
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__logical">Logical</h2>
<p>Logical operators short-circuit and return <code>1</code> or
<code>0</code>. <code>not</code> is a function, not an operator.</p>
<pre class="milang"><code>a = 1 &amp;&amp; 1
b = 1 &amp;&amp; 0
c = 0 || 1
d = 0 || 0
e = not 0
f = not 1
</code></pre>
<pre><code>a = 1
b = 0
c = 1
d = 0
e = 1
f = 0
</code></pre>
<p>Short-circuit evaluation means the right-hand side is never forced
when the left side determines the result:</p>
<pre class="milang"><code>safe = 0 &amp;&amp; (1 / 0)   -- 0, right side never evaluated
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__string-concatenation">String
Concatenation</h2>
<p>The <code>+</code> operator also concatenates strings:</p>
<pre class="milang"><code>greeting = &quot;hello&quot; + &quot; &quot; + &quot;world&quot;
</code></pre>
<pre><code>greeting = hello world
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__cons">Cons</h2>
<p>The <code>:</code> operator prepends an element to a list. It is
right-associative.</p>
<pre class="milang"><code>xs = 1 : 2 : 3 : []
</code></pre>
<pre><code>xs = [1, 2, 3]
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__pipe">Pipe</h2>
<p><code>x |&gt; f</code> is syntactic sugar for <code>f x</code>,
enabling left-to-right data flow:</p>
<pre class="milang"><code>double x = x * 2
result = 5 |&gt; double
</code></pre>
<pre><code>double = &lt;closure&gt;
result = 10
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__composition">Composition</h2>
<p><code>f &gt;&gt; g</code> composes left-to-right
(<code>\x -&gt; g (f x)</code>). <code>f &lt;&lt; g</code> composes
right-to-left (<code>\x -&gt; f (g x)</code>).</p>
<pre class="milang"><code>double x = x * 2
inc x = x + 1
pipeline = double &gt;&gt; inc
a = pipeline 5
</code></pre>
<pre><code>double = &lt;closure&gt;
inc = &lt;closure&gt;
pipeline = &lt;closure&gt;
a = 11
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__record-merge">Record
Merge</h2>
<p><code>a &lt;- b</code> produces a new record with all
<code>fields</code> from <code>a</code>, overwritten by
<code>fields</code> from <code>b</code>:</p>
<pre class="milang"><code>base = {x = 1; y = 2; z = 3}
updated = base &lt;- {x = 10; z = 30}
</code></pre>
<pre><code>base =  {x = 1, y = 2, z = 3}
updated =  {x = 10, y = 2, z = 30}
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__operators-as-functions">Operators
as Functions</h2>
<p>Wrap any operator in parentheses to use it in prefix (function)
position:</p>
<pre class="milang"><code>a = (+) 3 4
b = (*) 5 6
total = fold (+) 0 [1, 2, 3, 4, 5]
</code></pre>
<pre><code>a = 7
b = 30
total = 15
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__functions-as-infix-operators">Functions
as Infix Operators</h2>
<p>Surround a function name with backticks to use it as an infix
operator:</p>
<pre class="milang"><code>bigger = 3 `max` 7
smaller = 3 `min` 7
</code></pre>
<pre><code>bigger = 7
smaller = 3
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__operators.md__user-defined-operators">User-Defined
Operators</h2>
<p>You can define custom operators just like functions. Precedence and
associativity are set with the parse domain <code>:!</code>. See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__parse-decls.md__parse-declarations-">Parse
Declarations</a> and <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__user-defined-operators">User
Operators</a> chapters for details.</p>
<pre class="milang"><code>(&lt;=&gt;) a b = if (a == b) 0 (if (a &gt; b) 1 (0 - 1))
(&lt;=&gt;) :! {prec = 30; assoc = Left}
</code></pre>
<h1 data-number="8" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__records--adts"><span class="header-section-number">8</span> Records &amp; ADTs</h1>
<p>Records are milang&#39;s primary data structure. They hold named
<code>fields</code>, support structural updates, and form the basis of
algebraic data types (ADTs).</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__record-literals">Record
Literals</h2>
<p>A record is a set of <code>field = value</code> pairs inside braces,
separated by <code>;</code> or newlines:</p>
<pre class="milang"><code>point = {x = 3; y = 4}
person = {name = &quot;Alice&quot;; age = 30}
</code></pre>
<pre><code>point =  {x = 3, y = 4}
person =  {name = Alice, age = 30}
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__field-access">Field
Access</h2>
<p>Use dot notation to read a field. Dots chain for nested records.</p>
<pre class="milang"><code>point = {x = 3; y = 4}
a = point.x
b = point.y
</code></pre>
<pre><code>point =  {x = 3, y = 4}
a = 3
b = 4
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__positional-access">Positional
Access</h2>
<p>Fields can also be accessed by declaration order using
<code>_0</code>, <code>_1</code>, etc.:</p>
<pre class="milang"><code>pair = {first = &quot;hello&quot;; second = &quot;world&quot;}
a = pair._0
b = pair._1
</code></pre>
<pre><code>pair =  {first = hello, second = world}
a = hello
b = world
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__record-update">Record
Update</h2>
<p>The <code>&lt;-</code> operator creates a new record with selected
<code>fields</code> replaced. Fields not mentioned are carried over
unchanged.</p>
<pre class="milang"><code>base = {x = 1; y = 2; z = 3}
moved = base &lt;- {x = 10; z = 30}
</code></pre>
<pre><code>base =  {x = 1, y = 2, z = 3}
moved =  {x = 10, y = 2, z = 30}
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__destructuring">Destructuring</h2>
<p>Bind <code>fields</code> from a record directly into the current
scope. Use <code>{field}</code> for same-name bindings, or
<code>{local = field}</code> to rename:</p>
<pre class="milang"><code>point = {x = 3; y = 4}
{x; y} = point
sum = x + y
</code></pre>
<pre><code>point =  {x = 3, y = 4}
_destruct_23 =  {x = 3, y = 4}
x = 3
y = 4
</code></pre>
<p>Renaming during destructuring:</p>
<pre class="milang"><code>point = {x = 3; y = 4}
{myX = x; myY = y} = point
result = myX + myY
</code></pre>
<pre><code>point =  {x = 3, y = 4}
_destruct_23 =  {x = 3, y = 4}
myX = 3
myY = 4
result = 7
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__scope-as-record">Scope-as-Record</h2>
<p>When a function body has no explicit result expression — just
indented bindings — the named bindings are collected into an implicit
record:</p>
<pre class="milang"><code>makeVec x y =
  magnitude = x + y
  product = x * y
v = makeVec 3 4
</code></pre>
<pre><code>makeVec = &lt;closure&gt;
v =  {magnitude = 7, product = 12}
</code></pre>
<p>Bare expressions (not bound to a name) execute for their side effects
and are <strong>not</strong> included in the returned record. This is
how <code>main</code> works — see the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__scopes--bindings">Scopes</a>
chapter.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__adts-algebraic-data-types">ADTs
(Algebraic Data Types)</h2>
<p>An uppercase name bound to braces containing uppercase constructors
declares a tagged union:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height; Point}
c = Circle 5
r = Rect 3 4
p = Point
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;, Point = Point {}}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
Point = Point {}
c = Circle {radius = 5}
r = Rect {width = 3, height = 4}
p = Point {}
</code></pre>
<p>Each constructor becomes a function that produces a tagged record.
Zero-field constructors (like <code>Point</code> above) are plain tagged
records with no arguments.</p>
<p>Constructors are also available namespaced under the type name (e.g.
<code>Shape.Circle</code>).</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__constructors-as-functions">Constructors
as Functions</h2>
<p>Because constructors are just functions, they work naturally with
<code>map</code> and other higher-order functions:</p>
<pre class="milang"><code>values = map (\x -&gt; Just x) [1, 2, 3]
</code></pre>
<pre><code>values = [Just {val = 1}, Just {val = 2}, Just {val = 3}]
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__pattern-matching-on-tags">Pattern
Matching on Tags</h2>
<p>Use the <code>-&gt;</code> operator to match on a value&#39;s constructor
<code>tag</code>. After a <code>tag</code> matches, the record&#39;s
<code>fields</code> are accessible via dot notation or
destructuring:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}
area shape = shape -&gt;
  Circle = 3.14 * shape.radius * shape.radius
  Rect = shape.width * shape.height
a = area (Circle 5)
b = area (Rect 3 4)
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
area = &lt;closure&gt;
a = 78.5
b = 12
</code></pre>
<p>Named-field destructuring in alternatives:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}
area shape -&gt;
  Circle {radius} = 3.14 * radius * radius
  Rect {width; height} = width * height
a = area (Circle 5)
b = area (Rect 3 4)
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
area = &lt;closure&gt;
a = 78.5
b = 12
</code></pre>
<p>See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__pattern-matching">Pattern
Matching</a> chapter for the full range of patterns, guards, and list
matching.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__records.md__record-introspection">Record
Introspection</h2>
<p>Several built-in functions let you inspect records dynamically:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fields r</code></td>
<td>List of <code>{name, value}</code> records (<code>[]</code> for
non-records)</td>
</tr>
<tr>
<td><code>fieldNames r</code></td>
<td>List of field-name strings</td>
</tr>
<tr>
<td><code>tag r</code></td>
<td>Constructor <code>tag</code> string, or <code>&quot;&quot;</code> for untagged
values</td>
</tr>
<tr>
<td><code>getField r &quot;name&quot;</code></td>
<td><code>Just value</code> if present, <code>Nothing</code> if
missing</td>
</tr>
<tr>
<td><code>setField r &quot;name&quot; val</code></td>
<td>New record with field set</td>
</tr>
</tbody>
</table>
<h1 data-number="9" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__pattern-matching"><span class="header-section-number">9</span> Pattern Matching</h1>
<p>Pattern matching in milang uses the <code>-&gt;</code> operator to
dispatch on a value&#39;s shape. There are no keywords — <code>-&gt;</code>
is an expression that evaluates the first alternative whose pattern
matches.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__basic-syntax">Basic
Syntax</h2>
<p>Write <code>expr -&gt;</code> followed by alternatives. Each
alternative is <code>pattern = body</code>. Alternatives can appear
inline (separated by <code>;</code>) or indented on separate lines.</p>
<p>Inline:</p>
<pre class="milang"><code>classify x = x -&gt; 0 = &quot;zero&quot;; 1 = &quot;one&quot;; _ = &quot;other&quot;
a = classify 0
b = classify 1
c = classify 42
</code></pre>
<pre><code>classify = &lt;closure&gt;
a = zero
b = one
c = other
</code></pre>
<p>Indented:</p>
<pre class="milang"><code>classify x = x -&gt;
  0 = &quot;zero&quot;
  1 = &quot;one&quot;
  _ = &quot;other&quot;
a = classify 0
b = classify 1
c = classify 42
</code></pre>
<pre><code>classify = &lt;closure&gt;
a = zero
b = one
c = other
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__literal-patterns">Literal
Patterns</h2>
<p>Integers and strings match by exact value:</p>
<pre class="milang"><code>describe n = n -&gt;
  0 = &quot;zero&quot;
  1 = &quot;one&quot;
  _ = &quot;many&quot;
a = describe 0
b = describe 1
c = describe 99
</code></pre>
<pre><code>describe = &lt;closure&gt;
a = zero
b = one
c = many
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__variable-patterns">Variable
Patterns</h2>
<p>A lowercase name matches any value and binds it for use in the
body:</p>
<pre class="milang"><code>myAbs x = x -&gt;
  n | n &gt;= 0 = n
  n = 0 - n
a = myAbs 5
b = myAbs (0 - 3)
</code></pre>
<pre><code>myAbs = &lt;closure&gt;
a = 5
b = 3
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__wildcard">Wildcard</h2>
<p><code>_</code> matches any value without binding it. Use it for
catch-all branches:</p>
<pre class="milang"><code>isZero x = x -&gt;
  0 = 1
  _ = 0
a = isZero 0
b = isZero 7
</code></pre>
<pre><code>isZero = &lt;closure&gt;
a = 1
b = 0
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__constructor-tag-patterns">Constructor
Tag Patterns</h2>
<p>Match on a tagged record&#39;s constructor. After matching, the
scrutinee&#39;s <code>fields</code> are accessible through dot notation:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}
area shape = shape -&gt;
  Circle = 3.14 * shape.radius * shape.radius
  Rect = shape.width * shape.height
a = area (Circle 5)
b = area (Rect 3 4)
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
area = &lt;closure&gt;
a = 78.5
b = 12
</code></pre>
<p>With named-field destructuring in the pattern, <code>fields</code>
are bound directly:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}
area shape -&gt;
  Circle {radius} = 3.14 * radius * radius
  Rect {width; height} = width * height
a = area (Circle 5)
b = area (Rect 3 4)
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
area = &lt;closure&gt;
a = 78.5
b = 12
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__list-patterns">List
Patterns</h2>
<p>Match a list by its elements. <code>[a, b, c]</code> matches a list
of exactly three elements. <code>[first, ...rest]</code> matches one or
more elements, binding the <code>tail</code>:</p>
<pre class="milang"><code>xs = [10, 20, 30, 40]
result = xs -&gt;
  [a, b, ...rest] = {first = a; second = b; rest = rest}
  [] = {first = 0; second = 0; rest = []}
</code></pre>
<pre><code>xs = [10, 20, 30, 40]
result =  {first = 10, second = 20, rest = [30, 40]}
</code></pre>
<p>An empty-list pattern matches <code>[]</code> (<code>Nil</code>):</p>
<pre class="milang"><code>isEmpty xs = xs -&gt;
  [] = &quot;empty&quot;
  _ = &quot;non-empty&quot;
a = isEmpty []
b = isEmpty [1]
</code></pre>
<pre><code>isEmpty = &lt;closure&gt;
a = empty
b = non-empty
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__guards">Guards</h2>
<p>A guard adds a condition to an alternative using
<code>| condition</code> before the <code>=</code>. The alternative only
matches when both the pattern and the guard are satisfied:</p>
<pre class="milang"><code>classify x = x -&gt;
  n | n &lt; 0 = &quot;negative&quot;
  n | n == 0 = &quot;zero&quot;
  _ = &quot;positive&quot;
a = classify (0 - 5)
b = classify 0
c = classify 10
</code></pre>
<pre><code>classify = &lt;closure&gt;
a = negative
b = zero
c = positive
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__guard-only-matching">Guard-Only
Matching</h2>
<p>When every alternative uses only a guard (no structural pattern), you
can write guards directly after <code>-&gt;</code>:</p>
<pre class="milang"><code>classify x = x -&gt;
  | x &lt; 0 = &quot;negative&quot;
  | x == 0 = &quot;zero&quot;
  | _ = &quot;positive&quot;
a = classify (0 - 5)
b = classify 0
c = classify 10
</code></pre>
<pre><code>classify = &lt;closure&gt;
a = negative
b = zero
c = positive
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__combined-pattern--guard">Combined
Pattern + Guard</h2>
<p>A constructor or literal pattern can be paired with a guard:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}
safeArea shape -&gt;
  Circle {radius} | radius &gt; 0 = 3.14 * radius * radius
  _ = 0
a = safeArea (Circle 5)
b = safeArea (Circle 0)
c = safeArea (Rect 3 4)
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
safeArea = &lt;closure&gt;
a = 78.5
b = 0
c = 0
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__match-in-function-bindings">Match
in Function Bindings</h2>
<p>The <code>f param -&gt;</code> sugar defines a function that
immediately matches its <code>last</code> parameter, avoiding an extra
<code>= param -&gt;</code> layer:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}
describe label shape -&gt;
  Circle = label + &quot;: circle&quot;
  Rect = label + &quot;: rect&quot;
  _ = label + &quot;: unknown&quot;
a = describe &quot;shape&quot; (Circle 5)
b = describe &quot;shape&quot; (Rect 3 4)
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
describe = &lt;closure&gt;
a = shape: circle
b = shape: rect
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__exhaustiveness">Exhaustiveness</h2>
<p>When the compiler can determine the type of a scrutinee (e.g., from a
<code>::</code> type annotation), it checks that all constructors of a
union type are covered. If any constructor is missing and there is no
wildcard <code>_</code> catch-all, the compiler emits a warning:</p>
<pre class="text"><code>warning: non-exhaustive patterns for Shape — missing: Rect
</code></pre>
<p>To silence the warning, either cover all constructors explicitly or
add a wildcard branch:</p>
<pre class="milang"><code>area s = s -&gt;
  Circle = 3.14 * s.radius * s.radius
  _ = 0  -- catch-all for all other shapes
</code></pre>
<p>Exhaustiveness checking only triggers when the scrutinee type is a
known union type from a <code>::</code> annotation. Unannotated
scrutinees without a catch-all will compile without warning but may fail
at runtime if an unmatched constructor is encountered.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__pattern-matching.md__matching-maybe">Matching
Maybe</h2>
<pre class="milang"><code>matchMaybe m = m -&gt;
  Just {val} = &quot;Just(&quot; + toString val + &quot;)&quot;
  Nothing = &quot;Nothing&quot;

main world =
  world.io.println (matchMaybe (Just 5))
  world.io.println (matchMaybe Nothing)
</code></pre>
<pre><code>Just(5)
Nothing
</code></pre>
<h1 data-number="10" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__lists"><span class="header-section-number">10</span> Lists</h1>
<p>Lists in milang are singly-linked cons cells, declared in the prelude
as <code>List = {Nil; Cons head tail}</code>. The bracket syntax is
sugar that desugars into this representation.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__constructing-lists">Constructing
Lists</h2>
<pre class="milang"><code>nums = [1, 2, 3, 4, 5]
empty = []
consed = 10 : 20 : 30 : []
</code></pre>
<pre><code>nums = [1, 2, 3, 4, 5]
empty = []
consed = [10, 20, 30]
</code></pre>
<p><code>[]</code> is <code>Nil</code>, and <code>[1, 2, 3]</code>
desugars to <code>Cons 1 (Cons 2 (Cons 3 Nil))</code>. The
<code>:</code> operator (cons) is right-associative.</p>
<p>Use <code>range</code> to generate a sequence:</p>
<pre class="milang"><code>a = range 1 6
b = range 1 11
</code></pre>
<pre><code>a = [1, 2, 3, 4, 5]
b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__accessing-elements">Accessing
Elements</h2>
<p><code>head</code>, <code>tail</code>, <code>last</code>, and
<code>init</code> all return <code>Maybe</code> values —
<code>Just x</code> on success, <code>Nothing</code> on an empty list.
<code>at</code> returns <code>Maybe</code> for index access.</p>
<pre class="milang"><code>xs = [10, 20, 30]
a = head xs
b = tail xs
c = last xs
d = init xs
e = at xs 1
f = head []
</code></pre>
<pre><code>xs = [10, 20, 30]
a = Just {val = 10}
b = Just {val = [20, 30]}
c = Just {val = 30}
d = Just {val = [10, 20]}
e = Just {val = 20}
f = Nothing {}
</code></pre>
<p><code>len</code> returns the number of elements:</p>
<pre class="milang"><code>a = len [1, 2, 3]
b = len []
</code></pre>
<pre><code>a = 3
b = 0
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__transforming">Transforming</h2>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__map">map</h3>
<p>Apply a function to every element:</p>
<pre class="milang"><code>doubled = map (\x -&gt; x * 2) [1, 2, 3, 4, 5]
</code></pre>
<pre><code>doubled = [2, 4, 6, 8, 10]
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__filter">filter</h3>
<p>Keep elements satisfying a predicate:</p>
<pre class="milang"><code>evens = filter (\x -&gt; x % 2 == 0) [1, 2, 3, 4, 5, 6]
</code></pre>
<pre><code>evens = [2, 4, 6]
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__fold">fold</h3>
<p>Left-fold with an accumulator:</p>
<pre class="milang"><code>total = fold (+) 0 [1, 2, 3, 4, 5]
</code></pre>
<pre><code>total = 15
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__reverse">reverse</h3>
<pre class="milang"><code>backwards = reverse [1, 2, 3, 4, 5]
</code></pre>
<pre><code>backwards = [5, 4, 3, 2, 1]
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__take--drop">take
/ drop</h3>
<pre class="milang"><code>front = take 3 [1, 2, 3, 4, 5]
back = drop 3 [1, 2, 3, 4, 5]
</code></pre>
<pre><code>front = [1, 2, 3]
back = [4, 5]
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__zip">zip</h3>
<p>Pair up elements from two lists:</p>
<pre class="milang"><code>pairs = zip [1, 2, 3] [10, 20, 30]
</code></pre>
<pre><code>pairs = [[1, 10], [2, 20], [3, 30]]
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__enumerate">enumerate</h3>
<p>Produce <code>[index, value]</code> pairs:</p>
<pre class="milang"><code>indexed = enumerate [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>
<pre><code>indexed = [[0, a], [1, b], [2, c]]
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__combining-lists">Combining
Lists</h2>
<pre class="milang"><code>joined = concat [1, 2] [3, 4]
appended = push [1, 2, 3] 4
</code></pre>
<pre><code>joined = [1, 2, 3, 4]
appended = [1, 2, 3, 4]
</code></pre>
<p><code>join</code> concatenates a list of strings with a
separator:</p>
<pre class="milang"><code>csv = join &quot;, &quot; [&quot;alice&quot;, &quot;bob&quot;, &quot;carol&quot;]
</code></pre>
<pre><code>csv = alice, bob, carol
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__querying">Querying</h2>
<pre class="milang"><code>xs = [1, 2, 3, 4, 5]
a = sum xs
b = product xs
c = any (\x -&gt; x &gt; 4) xs
d = all (\x -&gt; x &gt; 0) xs
e = contains xs 3
f = contains xs 99
</code></pre>
<pre><code>xs = [1, 2, 3, 4, 5]
a = 15
b = 120
c = 1
d = 1
e = 1
f = 0
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__pipelines">Pipelines</h2>
<p>Lists work naturally with the pipe operator for readable data
processing:</p>
<pre class="milang"><code>result = range 1 11 \
  |&gt; filter (\x -&gt; x % 2 == 0) \
  |&gt; map (\x -&gt; x * x) \
  |&gt; sum
</code></pre>
<pre><code>result = 220
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__lists.md__pattern-matching-on-lists">Pattern
Matching on Lists</h2>
<p>Match by exact length with <code>[a, b, c]</code>, or match
<code>head</code> and <code>tail</code> with
<code>[first, ...rest]</code>:</p>
<pre class="milang"><code>xs = [10, 20, 30, 40]
result = xs -&gt;
  [a, b, ...rest] = a + b
  [] = 0
</code></pre>
<pre><code>xs = [10, 20, 30, 40]
result = 30
</code></pre>
<p>Recursive functions often pattern-match to walk a list:</p>
<pre class="milang"><code>mySum xs = xs -&gt;
  [x, ...rest] = x + mySum rest
  [] = 0
</code></pre>
<h1 data-number="11" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__scopes--bindings"><span class="header-section-number">11</span> Scopes &amp; Bindings</h1>
<p>Scopes are the backbone of milang&#39;s structure. Every indented block
and every brace-delimited block creates a new scope with its own
bindings.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__basic-bindings">Basic
Bindings</h2>
<pre class="milang"><code>name = expr            -- eager binding
name := expr           -- lazy binding (thunk, evaluated at most once)
name params = expr     -- function binding
</code></pre>
<pre class="milang"><code>x = 42
double x = x * 2
result = double x
</code></pre>
<pre><code>x = 42
double = &lt;closure&gt;
result = 84
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__indentation-sensitive-scoping">Indentation-Sensitive
Scoping</h2>
<p>Indented lines beneath a binding form a scope. There are two modes
depending on whether an explicit result expression appears after
<code>=</code>.</p>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__explicit-body">Explicit
Body</h3>
<p>When a binding has an expression directly after <code>=</code>, that
expression is the scope&#39;s return value. The indented children are local
definitions visible only inside that scope:</p>
<pre class="milang"><code>compute x = result
  doubled = x * 2
  result = doubled + 1
a = compute 7
</code></pre>
<pre><code>compute = &lt;closure&gt;
a = 15
</code></pre>
<p>Here <code>doubled</code> and <code>result</code> are local to
<code>compute</code>. The value of <code>compute 7</code> is the
expression after <code>=</code>, which is <code>result</code> (15).</p>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__implicit-record-scope-as-record">Implicit
Record (Scope-as-Record)</h3>
<p>When a binding has <strong>no</strong> expression after
<code>=</code> — only indented children — the named bindings are
collected into a record and returned automatically:</p>
<pre class="milang"><code>makeVec x y =
  sum = x + y
  product = x * y
v = makeVec 3 4
</code></pre>
<pre><code>makeVec = &lt;closure&gt;
v =  {sum = 7, product = 12}
</code></pre>
<p><code>makeVec 3 4</code> returns
<code>{sum = 7, product = 12}</code>. This is milang&#39;s lightweight
alternative to explicit record construction.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__inner-scopes-shadow-outer-names">Inner
Scopes Shadow Outer Names</h2>
<p>A binding in an inner scope shadows any identically-named binding
from an enclosing scope. The outer binding is unaffected:</p>
<pre class="milang"><code>x = 10
f = result
  x = 99
  result = x + 1
outer = x
inner = f
</code></pre>
<pre><code>x = 10
f = 100
outer = 10
inner = 100
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__inline-scopes-with-blocks">Inline
Scopes (With Blocks)</h2>
<p>Braces create an inline scope on a single line. The expression before
the braces is the return value, and the bindings inside are local:</p>
<pre class="milang"><code>f x = result { doubled = x * 2; result = doubled + 1 }
a = f 7
</code></pre>
<pre><code>f = &lt;closure&gt;
a = 15
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__bare-expressions-effect-statements">Bare
Expressions (Effect Statements)</h2>
<p>A bare expression in a scope — one not bound to a name — is evaluated
for its side effect. Its result is discarded and <strong>not</strong>
included in any implicit record:</p>
<pre class="milang"><code>main world =
  world.io.println &quot;hello&quot;    -- effect, result discarded
  world.io.println &quot;world&quot;    -- effect, result discarded
  0                           -- explicit body (exit code)
</code></pre>
<p>The first two lines run <code>println</code> for their side effects.
The final <code>0</code> is the return value of <code>main</code>.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__the-main-function-pattern">The
<code>main</code> Function Pattern</h2>
<p>A typical <code>main</code> combines all three concepts — local
bindings, bare effect expressions, and an explicit result:</p>
<pre class="milang"><code>main world =
  name = &quot;milang&quot;                      -- local binding
  world.io.println (&quot;Hello, &quot; + name)  -- bare effect
  0                                    -- return value (exit code)
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__scopes.md__binding-order">Binding
Order</h2>
<ul>
<li>Bindings evaluate top-to-bottom (left-to-right in brace
scopes).</li>
<li>Later bindings may reference earlier ones.</li>
<li>The compiler tracks impure (<code>world</code>-tainted) bindings and
guarantees they execute in declaration order via an auto-monad
spine.</li>
<li>Pure bindings can theoretically be reordered by the optimiser.</li>
</ul>
<h1 data-number="12" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__imports--modules"><span class="header-section-number">12</span> Imports &amp; Modules</h1>
<p>Every <code>.mi</code> file is a module. Importing a module evaluates
it and returns a record containing all of its top-level bindings. You
bind that record to a name and access its members with dot notation — no
special export lists or visibility modifiers.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__local-imports">Local
Imports</h2>
<p>Use <code>import</code> with a file path (relative to the importing
file&#39;s directory):</p>
<pre class="milang"><code>math = import &quot;lib/mymath.mi&quot;

area = math.circle_area 5
</code></pre>
<p>The result of <code>import</code> is a record, so
<code>math.circle_area</code> and <code>math.pi</code> access individual
bindings from the imported file.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__a-complete-example">A
Complete Example</h2>
<pre class="milang"><code>-- Suppose lib/mymath.mi contains:
--   pi = 3.14159
--   circle_area r = pi * r * r

-- We can inline the same definitions here to demonstrate:
pi = 3.14159
circle_area r = pi * r * r

circumference r = 2 * pi * r
</code></pre>
<pre><code>pi = 3.14159
circle_area = &lt;closure&gt;
circumference = &lt;closure&gt;
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__url-imports">URL
Imports</h2>
<p>Remote modules are imported the same way — just use a URL:</p>
<pre class="milang"><code>collections = import &quot;https://example.com/milang-stdlib/collections.mi&quot;

total = collections.sum [1, 2, 3]
</code></pre>
<p>The compiler downloads the file and caches it locally. On subsequent
runs the cached version is used.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__pinned-imports-with-import">Pinned
Imports with <code>import&#39;</code></h2>
<p>URL imports must be pinned by their SHA-256 hash using the
<code>import&#39;</code> form:</p>
<pre class="milang"><code>lib = import&#39; &quot;https://example.com/lib.mi&quot; ({sha256 = &quot;a1b2c3...&quot;})
</code></pre>
<p>If the downloaded content does not match the hash, compilation fails.
The <code>milang pin</code> command computes the hash for you:</p>
<div class="sourceCode" id="cb220"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> milang pin https://example.com/lib.mi</span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a><span class="ex">sha256</span> = <span class="st">&quot;a1b2c3d4e5f6...&quot;</span></span></code></pre></div>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__c-header-imports">C
Header Imports</h2>
<p>When the path ends in <code>.h</code>, the compiler parses the C
header and exposes its functions as milang bindings. See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__c-ffi">C
FFI</a> chapter for details.</p>
<pre class="milang"><code>m = import &quot;math.h&quot;
result = m.sin 1.0
</code></pre>
<p>You can also associate C source files and compiler flags with
<code>import&#39;</code>:</p>
<pre class="milang"><code>lib = import&#39; &quot;mylib.h&quot; ({src = &quot;mylib.c&quot;})
answer = lib.add_ints 3 4
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__circular-imports">Circular
Imports</h2>
<p>Milang supports circular imports. When module A imports module B and
B imports A, the resolver detects the cycle and marks the circular
bindings as lazy (thunks) to break the dependency. Both modules load
correctly and can reference each other&#39;s bindings.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__diamond-imports">Diamond
Imports</h2>
<p>If two modules both import the same third module, it is loaded and
evaluated only once. The two importers share the same record, so there
is no duplication or inconsistency.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__imports.md__visibility">Visibility</h2>
<p>All top-level bindings in a <code>.mi</code> file are exported —
there is no private/public distinction. If you want to signal that a
binding is an internal helper, use a naming convention such as an
underscore prefix (<code>_helper</code>), but the compiler does not
enforce this.</p>
<h1 data-number="13" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__io--the-world"><span class="header-section-number">13</span> IO &amp; the World</h1>
<p>Milang uses a capability-based IO model. Side effects are not global
— they flow through an explicit <code>world</code> record that the
runtime passes to <code>main</code>. If a function never receives
<code>world</code> (or a sub-record of it), it cannot perform IO.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__hello-world">Hello
World</h2>
<pre class="milang"><code>main world =
  world.io.println &quot;Hello, world!&quot;
</code></pre>
<pre><code>Hello, world!
</code></pre>
<p><code>main</code> is the program entry point. It receives
<code>world</code> and its return value becomes the process exit
code.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__the-world-record">The
World Record</h2>
<p><code>world</code> is a record containing sub-records for different
capabilities:</p>
<table>
<thead>
<tr>
<th>Path</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>world.io</code></td>
<td>Console IO (println, print, readLine)</td>
</tr>
<tr>
<td><code>world.fs.read</code></td>
<td>Read-only filesystem (file, exists)</td>
</tr>
<tr>
<td><code>world.fs.write</code></td>
<td>Write filesystem (file, append, remove)</td>
</tr>
<tr>
<td><code>world.fs</code></td>
<td>Full filesystem access (read + write)</td>
</tr>
<tr>
<td><code>world.process</code></td>
<td>Process execution and exit</td>
</tr>
<tr>
<td><code>world.argv</code></td>
<td>Command-line arguments (pure — no effect)</td>
</tr>
<tr>
<td><code>world.getEnv</code></td>
<td>Read environment variables</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__console-io">Console
IO</h2>
<pre class="milang"><code>world.io.println msg          -- print with trailing newline
world.io.print msg            -- print without newline
line = world.io.readLine      -- read one line from stdin
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__file-io">File
IO</h2>
<p>File operations are split by capability: <code>world.fs.read</code>
for reading and <code>world.fs.write</code> for writing. This enables
fine-grained trait annotations.</p>
<pre class="milang"><code>content = world.fs.read.file &quot;data.txt&quot;
world.fs.write.file &quot;out.txt&quot; content
world.fs.write.append &quot;log.txt&quot; &quot;new line\n&quot;
exists = world.fs.read.exists &quot;data.txt&quot;     -- returns 1 or 0
world.fs.write.remove &quot;tmp.txt&quot;
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__process">Process</h2>
<pre class="milang"><code>output = world.process.exec &quot;ls -la&quot;      -- run shell command, return output
world.process.exit 1                       -- exit immediately with status code
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__command-line-arguments-and-environment">Command-Line
Arguments and Environment</h2>
<p><code>world.argv</code> is an inert list — it does not perform IO, so
it is always available:</p>
<pre class="milang"><code>main world =
  world.io.println (len world.argv)
</code></pre>
<p><code>world.getEnv</code> reads an environment variable by name:</p>
<pre class="milang"><code>home = world.getEnv &quot;HOME&quot;
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__capability-restriction">Capability
Restriction</h2>
<p>Because capabilities are just record <code>fields</code>, you can
restrict what a helper function can do by passing only the sub-record it
needs:</p>
<pre class="milang"><code>greet io = io.println &quot;hello from restricted IO&quot;

main world =
  greet world.io
</code></pre>
<pre><code>hello from restricted IO
</code></pre>
<p><code>greet</code> receives <code>world.io</code> and can print, but
it structurally cannot access <code>world.process</code> — there is no
way for it to execute shell commands or exit the process.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__exit-code">Exit
Code</h2>
<p>The return value of <code>main</code> is used as the process exit
code. An integer is used directly; any non-integer value (record,
string, etc.) defaults to exit code 0.</p>
<pre class="milang"><code>main world =
  world.io.println &quot;exiting with code 0&quot;
</code></pre>
<pre><code>exiting with code 0
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__script-mode">Script
Mode</h2>
<p>When a file has no <code>main</code> binding that takes a parameter,
milang runs in script mode: every top-level binding is evaluated and
printed.</p>
<pre class="milang"><code>x = 6 * 7
y = x + 1
greeting = &quot;hello&quot;
</code></pre>
<pre><code>x = 42
y = 43
greeting = hello
</code></pre>
<p>This is useful for quick calculations and exploring the language
without writing a full <code>main</code> function.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__io.md__auto-monad-spine">Auto-Monad
Spine</h2>
<p>You do not need monads or do-notation in milang. The compiler
automatically tracks which expressions are
<em><code>world</code>-tainted</em> (they transitively reference
<code>world</code>). Impure expressions are guaranteed to execute in the
order they appear in the source. Pure expressions can float freely,
opening the door for future optimizations. The result is
imperative-looking code that is safe and predictable.</p>
<h1 data-number="14" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__c-ffi"><span class="header-section-number">14</span> C FFI</h1>
<p>Milang can call C functions directly by importing a <code>.h</code>
header file. The compiler parses the header, extracts function
signatures, and maps C types to milang types
(<code>int</code>/<code>long</code> -&gt; <code>Int</code>,
<code>double</code> -&gt; <code>Float</code>, <code>float</code> -&gt;
<code>Float&#39; 32</code>, <code>char*</code> -&gt; <code>Str</code>). At
code generation time the header is <code>#include</code>d and calls are
emitted inline — no wrapper overhead.</p>
<!-- FFI mapping for sized types

Sized milang types map to fixed-width C integer types in the FFI layer for
predictable ABI compatibility:

- `Int' 8`  -> `int8_t`
- `Int' 16` -> `int16_t`
- `Int' 32` -> `int32_t`
- `Int' 64` -> `int64_t`

- `UInt' 8`  -> `uint8_t`
- `UInt' 16` -> `uint16_t`
- `UInt' 32` -> `uint32_t`
- `UInt' 64` -> `uint64_t`

Floating milang types map to the natural C floating types for the precision
requested (e.g. `Float' 32` corresponds to `float`, `Float' 64` to `double`).

When importing C headers the compiler attempts to match C signatures to
milang types. If a direct mapping is not available the import step will raise
an error and prompt you to provide an explicit shim or a compatible signature.
-->
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__importing-c-headers">Importing
C Headers</h2>
<p>Import a system header the same way you import a <code>.mi</code>
file:</p>
<pre class="milang"><code>m = import &quot;math.h&quot;

result = m.sin 1.0
root = m.sqrt 144.0
</code></pre>
<p>The result is a record whose <code>fields</code> are the C functions
declared in the header. Use dot notation to call them.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__selective-import-with-import">Selective
Import with <code>import&#39;</code></h2>
<p>If you only need a few functions, or need to attach compilation
options, use the <code>import&#39;</code> form:</p>
<pre class="milang"><code>m = import&#39; &quot;math.h&quot; ({})
result = m.cos 0.0
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__associating-c-source-files">Associating
C Source Files</h2>
<p>For your own C libraries, tell the compiler which source files to
compile alongside the generated code:</p>
<pre class="milang"><code>lib = import&#39; &quot;mylib.h&quot; ({src = &quot;mylib.c&quot;})
answer = lib.add_ints 3 4
</code></pre>
<p>The <code>src</code> field takes a single source file path (relative
to the importing <code>.mi</code> file).</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__advanced-options">Advanced
Options</h2>
<p>The options record passed to <code>import&#39;</code> supports several
<code>fields</code>:</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 23%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>src</code></td>
<td><code>Str</code></td>
<td>Single C source file to compile</td>
</tr>
<tr>
<td><code>sources</code></td>
<td><code>List</code></td>
<td>Multiple source files: <code>[&quot;a.c&quot;, &quot;b.c&quot;]</code></td>
</tr>
<tr>
<td><code>flags</code></td>
<td><code>Str</code></td>
<td>Additional compiler flags (e.g. <code>&quot;-O2 -Wall&quot;</code>)</td>
</tr>
<tr>
<td><code>include</code></td>
<td><code>Str</code></td>
<td>Additional include directory</td>
</tr>
<tr>
<td><code>pkg</code></td>
<td><code>Str</code></td>
<td>pkg-config package name — auto-discovers flags and includes</td>
</tr>
</tbody>
</table>
<p>Example with multiple options:</p>
<pre class="milang"><code>lib = import&#39; &quot;mylib.h&quot; ({
  sources = [&quot;mylib.c&quot;, &quot;helpers.c&quot;]
  flags = &quot;-O2&quot;
  include = &quot;vendor/include&quot;
})
</code></pre>
<p>Using pkg-config for a system library:</p>
<pre class="milang"><code>json = import&#39; &quot;json-c/json.h&quot; ({pkg = &quot;json-c&quot;})
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__how-it-works">How
It Works</h2>
<ol>
<li>The import resolver reads the <code>.h</code> file and extracts
function declarations.</li>
<li>Each C function becomes an internal <code>CFunction</code> AST node
with its milang type signature.</li>
<li>During C code generation the header is <code>#include</code>d and
calls are emitted as direct C function calls.</li>
<li>Any associated source files are compiled and linked
automatically.</li>
</ol>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__ffi.md__security-considerations">Security
Considerations</h2>
<p>C code bypasses milang&#39;s capability model — a C function can perform
arbitrary IO, allocate memory, or call system APIs regardless of what
capabilities were passed to the milang caller. Use the following flags
to restrict FFI access:</p>
<ul>
<li><strong><code>--no-ffi</code></strong> — disallow all C header
imports. Any <code>import &quot;*.h&quot;</code> will fail.</li>
<li><strong><code>--no-remote-ffi</code></strong> — allow local
<code>.mi</code> files to use C FFI, but prevent URL-imported modules
from importing C headers. This stops remote code from escaping the
capability sandbox through native calls.</li>
</ul>
<p>These flags are especially important when running untrusted or
third-party milang code.</p>
<h1 data-number="15" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__standard-library-reference"><span class="header-section-number">15</span> Standard Library Reference</h1>
<p>This page documents all functions available in the milang prelude, C
builtins, and operators. Functions marked &quot;extensible&quot; can be extended
for user-defined types via <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__open-function-chaining">open
function chaining</a>.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__types">Types</h2>
<pre class="milang"><code>Bool = {True; False}
List = {Nil; Cons head tail}
Maybe = {Nothing; Just val}

-- Sized numeric type aliases (Int&#39;, UInt&#39;, Float&#39; are primitive constructors)
Int = Int&#39; 64       -- signed 64-bit integer
UInt = UInt&#39; 64     -- unsigned 64-bit integer
Float = Float&#39; 64   -- 64-bit floating-point
Byte = UInt&#39; 8      -- unsigned 8-bit integer
</code></pre>
<!-- Sized numeric type constructors

`Int'`, `UInt'`, and `Float'` are primitive type constructors that take a
compile-time bit-width argument (for example `Int' 8`, `UInt' 32`, `Float' 64`).
They provide precise control over numeric representation and arithmetic
semantics:

- `Int' n` — signed two's-complement integer of `n` bits (wraps modulo 2^n)
- `UInt' n` — unsigned integer of `n` bits (range 0..2^n-1)
- `Float' n` — floating-point with `n`-bit precision (commonly 32 or 64)

The prelude provides friendly aliases (`Int = Int' 64`, `UInt = UInt' 64`,
`Float = Float' 64`, `Byte = UInt' 8`) for convenience. Use the sized forms
when precise width or FFI compatibility is required.
-->
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__extensible-functions">Extensible
Functions</h2>
<p>These functions are designed to be extended via <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__open-function-chaining">open
function chaining</a> for user-defined types.</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 32%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>truthy</code></td>
<td><code>a : Num</code></td>
<td>Boolean coercion. Falsy: <code>0</code>, <code>0.0</code>,
<code>&quot;&quot;</code>, <code>False</code>, <code>Nil</code>. Truthy:
everything else. Used by <code>if</code>, guards, <code>not</code>,
<code>&amp;&amp;</code>, <code>||</code>.</td>
</tr>
<tr>
<td><code>toString</code></td>
<td><code>a : Str</code></td>
<td>String conversion. Handles <code>True</code>, <code>False</code>,
<code>Nil</code> symbolically; delegates to <code>_toString</code> for
primitives (int, float, string).</td>
</tr>
<tr>
<td><code>eq</code></td>
<td><code>a : a : Num</code></td>
<td>Equality. Default falls through to structural <code>==</code>. Used
by <code>contains</code>.</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__core-functions">Core
Functions</h2>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 32%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td><code>a : a</code></td>
<td>Identity function.</td>
</tr>
<tr>
<td><code>const</code></td>
<td><code>a : b : a</code></td>
<td>Returns first argument, ignores second.</td>
</tr>
<tr>
<td><code>flip</code></td>
<td><code>(a : b : c) : b : a : c</code></td>
<td>Flips the first two arguments of a function.</td>
</tr>
<tr>
<td><code>not</code></td>
<td><code>a : Num</code></td>
<td>Logical negation via <code>truthy</code>.</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__list-functions">List
Functions</h2>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 32%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>null</code></td>
<td><code>List : Num</code></td>
<td>Returns <code>1</code> if list is <code>Nil</code>, <code>0</code>
otherwise.</td>
</tr>
<tr>
<td><code>head</code></td>
<td><code>List : Maybe</code></td>
<td>First element wrapped in <code>Maybe</code> (<code>Nothing</code> if
empty).</td>
</tr>
<tr>
<td><code>tail</code></td>
<td><code>List : Maybe</code></td>
<td>Tail wrapped in <code>Maybe</code> (<code>Nothing</code> if
empty).</td>
</tr>
<tr>
<td><code>fold</code></td>
<td><code>(a : b : a) : a : List : a</code></td>
<td>Left fold over a list.</td>
</tr>
<tr>
<td><code>map</code></td>
<td><code>(a : b) : List : List</code></td>
<td>Apply function to each element.</td>
</tr>
<tr>
<td><code>filter</code></td>
<td><code>(a : Num) : List : List</code></td>
<td>Keep elements where predicate is <code>truthy</code>.</td>
</tr>
<tr>
<td><code>concat</code></td>
<td><code>List : List : List</code></td>
<td>Concatenate two lists.</td>
</tr>
<tr>
<td><code>push</code></td>
<td><code>List : a : List</code></td>
<td>Append element to end of list.</td>
</tr>
<tr>
<td><code>at</code></td>
<td><code>List : Num : Maybe</code></td>
<td>Get element at index (zero-based); returns <code>Nothing</code> if
out of bounds. <code>at&#39;</code> takes index first.</td>
</tr>
<tr>
<td><code>sum</code></td>
<td><code>List : Num</code></td>
<td>Sum of numeric list.</td>
</tr>
<tr>
<td><code>product</code></td>
<td><code>List : Num</code></td>
<td>Product of numeric list.</td>
</tr>
<tr>
<td><code>any</code></td>
<td><code>(a : Num) : List : Num</code></td>
<td><code>1</code> if predicate is <code>truthy</code> for any
element.</td>
</tr>
<tr>
<td><code>all</code></td>
<td><code>(a : Num) : List : Num</code></td>
<td><code>1</code> if predicate is <code>truthy</code> for all
elements.</td>
</tr>
<tr>
<td><code>contains</code></td>
<td><code>List : a : Num</code></td>
<td><code>1</code> if list contains element (via <code>eq</code>).</td>
</tr>
<tr>
<td><code>range</code></td>
<td><code>Num : Num : List</code></td>
<td>Integer range <code>[start, end)</code>.</td>
</tr>
<tr>
<td><code>zip</code></td>
<td><code>List : List : List</code></td>
<td>Pair corresponding elements into 2-element lists.</td>
</tr>
<tr>
<td><code>last</code></td>
<td><code>List : Maybe</code></td>
<td>Last element wrapped in <code>Maybe</code> (<code>Nothing</code> if
empty).</td>
</tr>
<tr>
<td><code>init</code></td>
<td><code>List : Maybe</code></td>
<td>All elements except the <code>last</code> wrapped in
<code>Maybe</code> (<code>Nothing</code> if empty).</td>
</tr>
<tr>
<td><code>reverse</code></td>
<td><code>List : List</code></td>
<td>Reverse a list.</td>
</tr>
<tr>
<td><code>take</code></td>
<td><code>Num : List : List</code></td>
<td>First <code>n</code> elements.</td>
</tr>
<tr>
<td><code>drop</code></td>
<td><code>Num : List : List</code></td>
<td>Drop first <code>n</code> elements.</td>
</tr>
<tr>
<td><code>enumerate</code></td>
<td><code>List : List</code></td>
<td>Pair each element with its index:
<code>[[0, a], [1, b], ...]</code>.</td>
</tr>
<tr>
<td><code>join</code></td>
<td><code>Str : List : Str</code></td>
<td>Join string list with separator.</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__numeric-functions">Numeric
Functions</h2>
<table>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abs</code></td>
<td><code>Num : Num</code></td>
<td>Absolute value.</td>
</tr>
<tr>
<td><code>neg</code></td>
<td><code>Num : Num</code></td>
<td>Negation (<code>0 - x</code>).</td>
</tr>
<tr>
<td><code>min</code></td>
<td><code>Num : Num : Num</code></td>
<td>Minimum of two numbers.</td>
</tr>
<tr>
<td><code>max</code></td>
<td><code>Num : Num : Num</code></td>
<td>Maximum of two numbers.</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__string-builtins">String
Builtins</h2>
<p>String operations provided by the C runtime:</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 32%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>len</code></td>
<td><code>a : Num</code></td>
<td>Length of a string or list; returns <code>0</code> for non-iterable
values.</td>
</tr>
<tr>
<td><code>strlen</code></td>
<td><code>Str : Num</code></td>
<td>Length of a string (alias for <code>len</code>).</td>
</tr>
<tr>
<td><code>charAt</code></td>
<td><code>Str : Num : Maybe</code></td>
<td>Character at index; returns <code>Just</code> a single-char string
when index is valid, or <code>Nothing</code> when out of range.</td>
</tr>
<tr>
<td><code>indexOf</code></td>
<td><code>Str : Str : Num</code></td>
<td>Index of first occurrence of substring (<code>-1</code> if not
found).</td>
</tr>
<tr>
<td><code>slice</code></td>
<td><code>Str : Num : Num : Str</code></td>
<td>Substring from start index to end index.</td>
</tr>
<tr>
<td><code>split</code></td>
<td><code>Str : Str : List</code></td>
<td>Split string by delimiter.</td>
</tr>
<tr>
<td><code>trim</code></td>
<td><code>Str : Str</code></td>
<td>Remove leading/trailing whitespace.</td>
</tr>
<tr>
<td><code>toUpper</code></td>
<td><code>Str : Str</code></td>
<td>Convert to uppercase.</td>
</tr>
<tr>
<td><code>toLower</code></td>
<td><code>Str : Str</code></td>
<td>Convert to lowercase.</td>
</tr>
<tr>
<td><code>replace</code></td>
<td><code>Str : Str : Str : Str</code></td>
<td>Replace all occurrences: <code>replace old new str</code>.</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__type-conversion-builtins">Type
Conversion Builtins</h2>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 32%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>toString</code></td>
<td><code>a : Str</code></td>
<td>Convert to string (extensible — see above).</td>
</tr>
<tr>
<td><code>toInt</code></td>
<td><code>a : Maybe</code></td>
<td>Convert to integer; returns <code>Just</code> on success (parsing or
conversion), <code>Nothing</code> on failure.</td>
</tr>
<tr>
<td><code>toFloat</code></td>
<td><code>a : Maybe</code></td>
<td>Convert to float; returns <code>Just</code> on success,
<code>Nothing</code> on failure.</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__record-introspection-builtins">Record
Introspection Builtins</h2>
<p>Functions for inspecting and modifying record structure at
runtime:</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 32%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag</code></td>
<td><code>Record : Str</code></td>
<td>Constructor <code>tag</code> name (e.g., <code>tag (Just 1)</code>
-&gt; <code>&quot;Just&quot;</code>).</td>
</tr>
<tr>
<td><code>fields</code></td>
<td><code>Record : List</code></td>
<td>List of field values; returns <code>[]</code> for non-record
values.</td>
</tr>
<tr>
<td><code>fieldNames</code></td>
<td><code>Record : List</code></td>
<td>List of field names; returns <code>[]</code> for non-record
values.</td>
</tr>
<tr>
<td><code>getField</code></td>
<td><code>Record : Str : Maybe</code></td>
<td>Dynamic field access by name; returns <code>Just value</code> if
present, <code>Nothing</code> otherwise.</td>
</tr>
<tr>
<td><code>setField</code></td>
<td><code>Record : Str : a : Record</code></td>
<td>Return copy with field updated; on non-record values returns the
original value unchanged.</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__operators">Operators</h2>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 32%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr>
<th>Operator</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>|&gt;</code></td>
<td><code>a : (a : b) : b</code></td>
<td>Pipe forward: <code>x |&gt; f</code> = <code>f x</code>.</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td><code>(a : b) : (b : c) : a : c</code></td>
<td>Forward composition.</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td><code>(b : c) : (a : b) : a : c</code></td>
<td>Backward composition.</td>
</tr>
<tr>
<td><code>&lt;-</code></td>
<td><code>Record : Record : Record</code></td>
<td>Record merge: <code>base &lt;- overlay</code>.</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td><code>a : a : Num</code></td>
<td>Short-circuit logical AND (via <code>truthy</code>).</td>
</tr>
<tr>
<td><code>||</code></td>
<td><code>a : a : Num</code></td>
<td>Short-circuit logical OR (via <code>truthy</code>).</td>
</tr>
<tr>
<td><code>:</code></td>
<td><code>a : List : List</code></td>
<td>Cons (prepend element to list).</td>
</tr>
<tr>
<td><code>+</code> <code>-</code> <code>*</code> <code>/</code>
<code>%</code> <code>**</code></td>
<td><code>Num : Num : Num</code></td>
<td>Arithmetic (<code>+</code> also concatenates strings;
<code>**</code> takes an integer exponent).</td>
</tr>
<tr>
<td><code>==</code> <code>/=</code> <code>&lt;</code> <code>&gt;</code>
<code>&lt;=</code> <code>&gt;=</code></td>
<td><code>a : a : Num</code></td>
<td>Comparison (structural equality for records).</td>
</tr>
</tbody>
</table>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__stdlib.md__maybe-examples">Maybe
examples</h2>
<pre class="milang"><code>-- Maybe-returning stdlib usage
p1 = toInt &quot;123&quot;
p2 = toInt &quot;abc&quot;
p3 = toFloat &quot;3.14&quot;
r = {a = 1}

show mi = mi -&gt; Just {val} = toString val; Nothing = &quot;Nothing&quot;

main world =
  world.io.println (show p1)
  world.io.println (show p2)
  world.io.println (toString p3)
  world.io.println (show (getField r &quot;a&quot;))
  world.io.println (show (getField r &quot;b&quot;))
</code></pre>
<pre><code>123
Nothing
Just(3.14)
1
Nothing
</code></pre>
<h1 data-number="16" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__type-annotations-"><span class="header-section-number">16</span> Type Annotations
(<code>::</code>)</h1>
<p>Type annotations in milang are optional — the compiler infers types.
When you do annotate, you use the <code>::</code> domain to attach a
type expression to a binding. Annotations are separate lines that merge
with the corresponding value binding.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__syntax">Syntax</h2>
<pre class="milang"><code>name :: typeExpr
name args = body
</code></pre>
<p>Inside a type expression, <code>:</code> means &quot;function type&quot; and is
right-associative. So <code>Num : Num : Num</code> means &quot;a function
that takes a <code>Num</code>, then a <code>Num</code>, and returns a
<code>Num</code>.&quot;</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__primitive-types">Primitive
Types</h2>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Num</code></td>
<td>Alias for <code>Int</code> (backward compatibility)</td>
</tr>
<tr>
<td><code>Int</code></td>
<td>Signed 64-bit integer (alias for <code>Int&#39; 64</code>)</td>
</tr>
<tr>
<td><code>UInt</code></td>
<td>Unsigned 64-bit integer (alias for <code>UInt&#39; 64</code>)</td>
</tr>
<tr>
<td><code>Float</code></td>
<td>64-bit floating-point (alias for <code>Float&#39; 64</code>)</td>
</tr>
<tr>
<td><code>Byte</code></td>
<td>Unsigned 8-bit integer (alias for <code>UInt&#39; 8</code>)</td>
</tr>
<tr>
<td><code>Str</code></td>
<td>String</td>
</tr>
<tr>
<td><code>List</code></td>
<td>Linked list (Cons/<code>Nil</code>)</td>
</tr>
</tbody>
</table>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__sized-numeric-types">Sized
Numeric Types</h3>
<p>The primitive type constructors <code>Int&#39;</code>,
<code>UInt&#39;</code>, and <code>Float&#39;</code> take a compile-time bit
width:</p>
<pre class="milang"><code>add8 :: Int&#39; 8 : Int&#39; 8 : Int&#39; 8
add8 a b = a + b

compact :: Float&#39; 32 : Float&#39; 32
compact x = x * 1.0
</code></pre>
<p>The prelude defines convenient aliases:</p>
<pre class="milang"><code>Int = Int&#39; 64
UInt = UInt&#39; 64
Float = Float&#39; 64
Byte = UInt&#39; 8
</code></pre>
<p>You can define your own aliases:</p>
<pre class="milang"><code>Short = Int&#39; 16
Word = UInt&#39; 32
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__details-on-sized-numeric-types">Details
on Sized Numeric Types</h3>
<p>The primitive constructors <code>Int&#39;</code>, <code>UInt&#39;</code>, and
<code>Float&#39;</code> take a compile-time bit-width argument and provide
fixed-width numeric types. The language treats these as distinct
primitive types rather than mere annotations:</p>
<ul>
<li><p>Signed integers (<code>Int&#39; n</code>) use two&#39;s-complement
semantics; arithmetic on signed integers is performed modulo 2^n and
results are interpreted in two&#39;s complement when read as signed values.
Overflow wraps around (modular arithmetic).</p></li>
<li><p>Unsigned integers (<code>UInt&#39; n</code>) are arithmetic modulo
2^n with values in the range [0, 2^n-1]. Mixing signed and unsigned
operands follows a conservative promotion model: the operands are first
promoted to the wider bit-width and if any operand is unsigned the
operation is performed in the unsigned domain of that width.</p></li>
<li><p>Floating-point types (<code>Float&#39; 32</code>,
<code>Float&#39; 64</code>) correspond to standard IEEE-like single- and
double-precision floats. Arithmetic on mixed-width floats promotes to
the wider precision before performing the operation.</p></li>
</ul>
<h4 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__promotion-and-result-width">Promotion
and Result Width</h4>
<ul>
<li>For integer arithmetic, the result width is the maximum of the
operand widths after promotion; the resulting value is wrapped/clamped
to that width as described above.</li>
<li>For mixed signed/unsigned arithmetic the operation is performed in
the unsigned interpretation of the promoted width.</li>
</ul>
<h4 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__compile-time-requirements-and-partial-evaluation">Compile-time
Requirements and Partial Evaluation</h4>
<ul>
<li>The bit-width argument (the <code>n</code> in <code>Int&#39; n</code>)
must be a compile-time constant. The reducer treats sized-type aliases
(for example <code>Int = Int&#39; 64</code>) as syntactic sugar and reduces
type aliases away.</li>
<li>Note: currently the compiler treats sized types primarily as
type-level annotations and for FFI/representation purposes. Constant
arithmetic is evaluated by the reducer using Milang&#39;s unbounded numeric
semantics (or the platform default) and is not automatically
wrapped/clamped to a target bit width. If exact width-limited arithmetic
is required, use explicit conversion primitives or perform the operation
in C via the FFI.</li>
</ul>
<h4 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__practical-notes">Practical
Notes</h4>
<ul>
<li>Use sized types when you need explicit control over representation
and ABI compatibility (FFI interop, binary formats, embedded
targets).</li>
<li>The prelude exposes convenient aliases (<code>Int</code>,
<code>UInt</code>, <code>Float</code>, <code>Byte</code>) for common
widths; you can define your own aliases like
<code>Short = Int&#39; 16</code>.</li>
</ul>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__basic-examples">Basic
Examples</h2>
<pre class="milang"><code>double :: Num : Num
double x = x * 2

add :: Num : Num : Num
add a b = a + b

greeting :: Str : Str
greeting name = &quot;Hello, &quot; + name

result = add (double 3) 4
message = greeting &quot;milang&quot;
</code></pre>
<pre><code>double = &lt;closure&gt;
add = &lt;closure&gt;
greeting = &lt;closure&gt;
result = 10
message = Hello, milang
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__record-types">Record
Types</h2>
<p>Record types describe the shape of a record — field names and their
types:</p>
<pre class="milang"><code>Point :: {x = Num; y = Num}
</code></pre>
<p>You can use a named record type in function signatures:</p>
<pre class="milang"><code>Point :: {x = Num; y = Num}

mkPoint :: Num : Num : Point
mkPoint x y = {x = x; y = y}

p = mkPoint 3 4
</code></pre>
<pre><code>mkPoint = &lt;closure&gt;
p =  {x = 3, y = 4}
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__polymorphism-type-variables">Polymorphism
(Type Variables)</h2>
<p>Any unbound identifier in a type expression is automatically a type
variable. There is no <code>forall</code> keyword — just use lowercase
names:</p>
<pre class="milang"><code>apply :: (a : b) : a : b
apply f x = f x
</code></pre>
<p>Here <code>a</code> and <code>b</code> are type variables.
<code>apply</code> works for any function type <code>a : b</code>
applied to an <code>a</code>, producing a <code>b</code>.</p>
<pre class="milang"><code>apply :: (a : b) : a : b
apply f x = f x

double x = x * 2
result = apply double 21
</code></pre>
<pre><code>apply = &lt;closure&gt;
double = &lt;closure&gt;
result = 42
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__adt-types">ADT
Types</h2>
<p>You can annotate functions that operate on algebraic data types:</p>
<pre class="milang"><code>Shape = {Circle radius; Rect width height}

area :: Shape : Num
area s = s -&gt;
  Circle = 3 * s.radius * s.radius
  Rect = s.width * s.height

a = area (Circle 5)
b = area (Rect 3 4)
</code></pre>
<pre><code>Shape = _module_ {Circle = &lt;closure&gt;, Rect = &lt;closure&gt;}
Circle = &lt;closure&gt;
Rect = &lt;closure&gt;
area = &lt;closure&gt;
a = 75
b = 12
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__the-dual-meaning-of-">The
Dual Meaning of <code>:</code></h2>
<p>The <code>:</code> symbol is overloaded depending on context:</p>
<ul>
<li><strong>Value domain:</strong> cons operator —
<code>1 : [2, 3]</code> builds a list</li>
<li><strong>Type domain:</strong> function arrow —
<code>Num : Num : Num</code> describes a function</li>
</ul>
<p>This works because <code>::</code> on its own line clearly marks the
boundary between value code and type code. There is never ambiguity.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__types.md__type-checking-behavior">Type
Checking Behavior</h2>
<p>The type checker is bidirectional: it pushes <code>::</code>
annotations downward and infers types bottom-up. Type errors are
reported as errors. Checking is structural — records match by shape
(field names and types), not by name. Any record with the right
<code>fields</code> satisfies a record type.</p>
<h1 data-number="17" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__traits--effects-"><span class="header-section-number">17</span> Traits &amp; Effects
(<code>:~</code>)</h1>
<p>The <code>:~</code> annotation domain attaches trait or effect
information to a binding. It describes <em>what capabilities</em> a
function uses — console IO, file reads, process execution, and so on.
Traits annotations are orthogonal to type annotations (<code>::</code>)
and can coexist on the same binding.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__syntax">Syntax</h2>
<pre class="milang"><code>name :~ traitsExpr
</code></pre>
<p>The traits expression is typically a list of effect names:</p>
<pre class="milang"><code>greet :~ [console]
greet world = world.io.println &quot;hello&quot;
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__effect-names">Effect
Names</h2>
<table>
<thead>
<tr>
<th>Effect</th>
<th>Capabilities covered</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>console</code></td>
<td><code>println</code>, <code>print</code>, <code>readLine</code></td>
</tr>
<tr>
<td><code>fs.read</code></td>
<td><code>readFile</code>, <code>exists</code></td>
</tr>
<tr>
<td><code>fs.write</code></td>
<td><code>writeFile</code>, <code>appendFile</code>,
<code>remove</code></td>
</tr>
<tr>
<td><code>exec</code></td>
<td><code>process.exec</code></td>
</tr>
<tr>
<td><code>env</code></td>
<td><code>getEnv</code></td>
</tr>
</tbody>
</table>
<p>Use <code>[]</code> (empty list) or define a name bound to
<code>[]</code> to declare a function as pure:</p>
<pre class="milang"><code>pure :~ []

add :~ pure
add a b = a + b
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__defining-effect-groups">Defining
Effect Groups</h2>
<p>You can define reusable groups of effects:</p>
<pre class="milang"><code>readonly :~ [console, fs.read]
readwrite :~ [console, fs.read, fs.write]
</code></pre>
<p>Then reference those groups in other annotations.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__example">Example</h2>
<pre class="milang"><code>distance :~ []
distance x1 y1 x2 y2 = (x2 - x1)**2 + (y2 - y1)**2

main world =
  world.io.println (distance 0 0 3 4)
</code></pre>
<pre><code>25
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__combining-with-other-domains">Combining
with Other Domains</h2>
<p>All annotation domains can coexist on a single binding:</p>
<pre class="milang"><code>add :? &quot;Add two numbers&quot;
add :: Num : Num : Num
add :~ []
add a b = a + b
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__traits.md__current-status">Current
Status</h2>
<p>Trait annotations are parsed, stored, and <strong>enforced</strong>
by the compiler. The compiler performs taint analysis: it tracks the
<code>world</code> value and any names that transitively reference it
(via aliasing or closures), then infers the effect set of every binding.
If a function&#39;s inferred effects are not a subset of its declared
traits, the compiler emits an error.</p>
<p><strong>Functions without a <code>:~</code> annotation are assumed
pure</strong> (<code>:~ []</code>). This means any function that
performs IO must declare its effects. The only exception is
<code>main</code>, which is implicitly granted all capabilities.</p>
<p>For example, declaring <code>:~ []</code> (pure) but calling
<code>world.io.println</code> inside the body is a compile error — and
so is omitting the annotation entirely:</p>
<pre class="milang"><code>-- This is an error: no annotation, so assumed pure, but uses console
helper world = world.io.println &quot;oops&quot;

-- Fix: add trait annotation
helper :~ [console]
helper world = world.io.println &quot;ok&quot;
</code></pre>
<h1 data-number="18" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__documentation-"><span class="header-section-number">18</span> Documentation
(<code>:?</code>)</h1>
<p>The <code>:?</code> annotation domain attaches documentation to a
binding. Doc expressions are ordinary milang expressions — usually
strings or structured records — that the compiler stores as compile-time
metadata. They do not affect runtime behavior.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__simple-string-docs">Simple
String Docs</h2>
<p>The most common form is a short description string:</p>
<pre class="milang"><code>add :? &quot;Add two numbers&quot;
add a b = a + b
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__structured-docs">Structured
Docs</h2>
<p>For richer documentation, use a record with <code>fields</code> like
<code>summary</code>, <code>params</code>, and <code>returns</code>:</p>
<pre class="milang"><code>distance :? {
  summary = &quot;Squared distance between two points&quot;
  params = {
    x1 = &quot;First x coordinate&quot;
    y1 = &quot;First y coordinate&quot;
    x2 = &quot;Second x coordinate&quot;
    y2 = &quot;Second y coordinate&quot;
  }
  returns = &quot;The squared distance as a number&quot;
}
distance x1 y1 x2 y2 = (x2 - x1)**2 + (y2 - y1)**2
</code></pre>
<p>The field names are not enforced — you can use whatever structure
makes sense for your project.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__triple-quoted-string-docs">Triple-Quoted
String Docs</h2>
<p>For multi-line documentation, use triple-quoted strings. Margin
stripping (based on the closing <code>&quot;&quot;&quot;</code> indentation) keeps the
source tidy:</p>
<pre class="milang"><code>greet :? &quot;&quot;&quot;
  Greet a person by name.
  Prints a friendly message to the console.
  &quot;&quot;&quot;
greet world name = world.io.println (&quot;Hello, &quot; + name + &quot;!&quot;)
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__example">Example</h2>
<pre class="milang"><code>add :? &quot;Add two numbers&quot;
add :: Num : Num : Num
add a b = a + b

distance :? {summary = &quot;Squared distance&quot;; returns = &quot;Num&quot;}
distance x1 y1 x2 y2 = (x2 - x1)**2 + (y2 - y1)**2

main world =
  world.io.println (add 3 4)
  world.io.println (distance 0 0 3 4)
</code></pre>
<pre><code>7
25
</code></pre>
<p>Doc annotations do not change execution — the output above is the
same with or without <code>:?</code> lines.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__combining-all-five-domains">Combining
All Five Domains</h2>
<p>Every annotation domain can coexist on a single binding:</p>
<pre class="milang"><code>distance :? &quot;Squared Euclidean distance&quot;
distance :: Num : Num : Num : Num : Num
distance :~ []
distance x1 y1 x2 y2 = (x2 - x1)**2 + (y2 - y1)**2
</code></pre>
<p>The domains are <code>=</code> (value), <code>::</code> (type),
<code>:~</code> (traits), <code>:?</code> (docs), and <code>:!</code>
(parse). They are independent and can appear in any order before the
value binding.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__docs.md__future-milang-doc">Future:
<code>milang doc</code></h2>
<p>A planned <code>milang doc</code> command will extract
<code>:?</code> annotations from source files and generate reference
documentation automatically.</p>
<h1 data-number="19" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__parse-decls.md__parse-declarations-"><span class="header-section-number">19</span> Parse Declarations
(<code>:!</code>)</h1>
<p>The <code>:!</code> annotation domain declares how the parser should
handle a user-defined operator — specifically its precedence and
associativity. The parser pre-scans the source for <code>:!</code>
declarations before parsing expressions, so they take effect
immediately.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__parse-decls.md__syntax">Syntax</h2>
<pre class="milang"><code>(op) :! {prec = N; assoc = Left}
</code></pre>
<ul>
<li><strong><code>prec</code></strong> — an integer precedence level.
Higher values bind more tightly.</li>
<li><strong><code>assoc</code></strong> — one of <code>Left</code>,
<code>Right</code>, or <code>None</code>. Determines how chains of the
same operator group:
<ul>
<li><code>Left</code>: <code>a op b op c</code> parses as
<code>(a op b) op c</code></li>
<li><code>Right</code>: <code>a op b op c</code> parses as
<code>a op (b op c)</code></li>
<li><code>None</code>: chaining is a parse error; explicit parentheses
are required.</li>
</ul></li>
</ul>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__parse-decls.md__example">Example</h2>
<pre class="milang"><code>(&lt;=&gt;) :! {prec = 30; assoc = Left}
(&lt;=&gt;) a b = if (a == b) 0 (if (a &gt; b) 1 (0 - 1))

cmp1 = 5 &lt;=&gt; 3
cmp2 = 3 &lt;=&gt; 3
cmp3 = 1 &lt;=&gt; 5
</code></pre>
<pre><code>&lt;=&gt; = &lt;closure&gt;
cmp1 = 1
cmp2 = 0
cmp3 = -1
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__parse-decls.md__built-in-operator-precedences">Built-in
Operator Precedences</h2>
<p>For reference, the approximate precedence levels of built-in
operators:</p>
<table>
<thead>
<tr>
<th>Precedence</th>
<th>Operators</th>
<th>Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>|&gt;</code> <code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td>Left</td>
</tr>
<tr>
<td>2</td>
<td><code>||</code></td>
<td>Left</td>
</tr>
<tr>
<td>3</td>
<td><code>&amp;&amp;</code></td>
<td>Left</td>
</tr>
<tr>
<td>4</td>
<td><code>==</code> <code>/=</code> <code>&lt;</code> <code>&gt;</code>
<code>&lt;=</code> <code>&gt;=</code></td>
<td>Left</td>
</tr>
<tr>
<td>5</td>
<td><code>:</code></td>
<td>Right</td>
</tr>
<tr>
<td>6</td>
<td><code>+</code> <code>-</code> <code>++</code></td>
<td>Left</td>
</tr>
<tr>
<td>7</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>Left</td>
</tr>
<tr>
<td>8</td>
<td><code>**</code></td>
<td>Right</td>
</tr>
</tbody>
</table>
<p>User-defined operators without a <code>:!</code> declaration receive
a default precedence. Define <code>:!</code> to override this and
integrate your operator naturally with built-in ones.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__parse-decls.md__metaprogramming-hook">Metaprogramming
Hook</h2>
<p>Because <code>:!</code> declarations are processed during parsing
(before evaluation), they serve as a metaprogramming hook — they let you
reshape how the parser reads subsequent expressions. Combined with
user-defined operators, this gives you control over the syntactic
structure of your programs.</p>
<h1 data-number="20" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__open-function-chaining"><span class="header-section-number">20</span> Open Function Chaining</h1>
<p>Milang supports <strong>open function chaining</strong> — when you
redefine a function that uses pattern matching (the <code>-&gt;</code>
arrow), your new alternatives are automatically prepended to the
existing definition. The previous definition becomes the fallback for
values that don&#39;t match your new patterns.</p>
<p>This is milang&#39;s answer to typeclasses: no new syntax, no special
declarations. <code>Just</code> define the same function again with new
patterns.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__how-it-works">How
It Works</h2>
<p>When a binding is redefined in the same scope and the new definition
uses pattern matching (<code>-&gt;</code>) <strong>without a catch-all
wildcard</strong> (<code>_</code>), the compiler chains the two
definitions together. The new alternatives are tried first; if none
match, the old definition handles the value.</p>
<p>If the new definition <strong>includes</strong> a catch-all wildcard,
it fully replaces the old definition — the catch-all means &quot;I handle
everything.&quot;</p>
<pre class="milang"><code>-- Base: has catch-all
describe val = val -&gt; _ = &quot;unknown&quot;

-- Extension: no catch-all — chains with base
describe val = val -&gt; Circle = &quot;a circle&quot;; Rect = &quot;a rectangle&quot;
</code></pre>
<p>Now <code>describe (Circle 5)</code> returns <code>&quot;a circle&quot;</code>
and <code>describe 42</code> falls through to the base, returning
<code>&quot;unknown&quot;</code>.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__extensible-builtins">Extensible
Builtins</h2>
<p>Three core prelude functions are designed to be extended this
way:</p>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__truthy"><code>truthy</code></h3>
<p><code>truthy</code> is the universal boolean coercion point. It is
called internally by <code>if</code>, guards, <code>not</code>,
<code>&amp;&amp;</code>, and <code>||</code>. The prelude default treats
<code>0</code>, <code>0.0</code>, <code>&quot;&quot;</code>, <code>False</code>,
<code>Nil</code>, and <code>Nothing</code> as falsy (returns
<code>0</code>); everything else is <code>truthy</code> (returns
<code>1</code>).</p>
<p>Extend <code>truthy</code> to teach the language how your types
behave in boolean contexts:</p>
<pre class="milang"><code>Result = {Err msg; Ok val}
truthy val = val -&gt; Err = 0; Ok = 1

main world =
  world.io.println (toString (if (Ok 42) &quot;yes&quot; &quot;no&quot;))
  world.io.println (toString (if (Err &quot;oops&quot;) &quot;yes&quot; &quot;no&quot;))
  world.io.println (toString (not (Err &quot;fail&quot;)))
</code></pre>
<pre><code>yes
no
1
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__tostring"><code>toString</code></h3>
<p><code>toString</code> converts values to their string representation.
The prelude handles <code>True</code>, <code>False</code>,
<code>Nil</code>, <code>Nothing</code>, and <code>Just</code>
symbolically, then falls through to <code>_toString</code> (the C-level
primitive) for ints, floats, and strings. Extend it for your own
types:</p>
<pre class="milang"><code>Pair = {Pair fst snd}
toString val = val -&gt; Pair = &quot;(&quot; + toString val.fst + &quot;, &quot; + toString val.snd + &quot;)&quot;

main world =
  world.io.println (toString (Pair 1 2))
  world.io.println (toString (Pair &quot;hello&quot; True))
</code></pre>
<pre><code>(1, 2)
(hello, True)
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__eq"><code>eq</code></h3>
<p><code>eq</code> is the extensible equality function. The prelude
default falls through to structural <code>==</code>. The
<code>contains</code> function uses <code>eq</code>, so extending
<code>eq</code> automatically affects list membership checks:</p>
<pre class="milang"><code>Card = {Card rank suit}
eq a b = a -&gt; Card = a.rank == b.rank

main world =
  world.io.println (toString (eq (Card 10 &quot;H&quot;) (Card 10 &quot;S&quot;)))
  world.io.println (toString (contains [Card 10 &quot;H&quot;, Card 5 &quot;D&quot;] (Card 10 &quot;S&quot;)))
</code></pre>
<pre><code>1
0
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__scope-chaining">Scope
Chaining</h2>
<p>Open chaining works across scopes. A redefinition inside a function
body (a <code>With</code> block) chains with the outer scope&#39;s
definition, not just same-scope duplicates. Multiple levels of chaining
compose naturally:</p>
<pre class="milang"><code>Result = {Err msg; Ok val}
truthy val = val -&gt; Err = 0; Ok = 1

main world =
  Severity = {Low; High}
  truthy val = val -&gt; Low = 0; High = 1
  -- truthy now handles Result, Severity, AND all prelude types
  world.io.println (toString (truthy (Ok 1)))
  world.io.println (toString (truthy (Err &quot;x&quot;)))
  world.io.println (toString (truthy High))
  world.io.println (toString (truthy Low))
  world.io.println (toString (truthy Nothing))
</code></pre>
<pre><code>1
0
1
0
0
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__open-functions.md__writing-extensible-functions">Writing
Extensible Functions</h2>
<p>To make your own functions extensible, follow this pattern:</p>
<ol>
<li><strong>Define a base</strong> with a catch-all wildcard — this
provides default behavior.</li>
<li><strong>Extend without a catch-all</strong> — your new alternatives
are prepended; the base stays as fallback.</li>
</ol>
<pre class="milang"><code>-- Base definition (has catch-all)
describe val = val -&gt; _ = &quot;something&quot;

-- Extension (no catch-all — chains)
Shape = {Circle radius; Rect width height}
describe val = val -&gt; Circle = &quot;a circle&quot;; Rect = &quot;a rectangle&quot;

main world =
  world.io.println (describe (Circle 5))
  world.io.println (describe (Rect 3 4))
  world.io.println (describe 42)
</code></pre>
<pre><code>a circle
a rectangle
something
</code></pre>
<p>If you include a catch-all in an extension, it fully replaces the
base — use this when you genuinely want to override all behavior.</p>
<h1 data-number="21" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__partial-evaluation"><span class="header-section-number">21</span> Partial Evaluation</h1>
<p>Partial evaluation is milang&#39;s core compilation model. There is no
separate optimisation pass — the compiler itself evaluates every
expression whose inputs are known at compile time and emits C code only
for what remains. The result is that high-level abstractions (helper
functions, configuration records, computed constants) often carry
<strong>zero runtime cost</strong>.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__how-it-works">How
it works</h2>
<p>When the compiler processes a binding it walks the expression tree
with a recursive reducer (<code>reduceD</code>). At each node it checks
whether the operands are <em>concrete</em> — literal integers, floats,
strings, lambdas, or records whose <code>fields</code> are themselves
concrete. If they are, the expression is evaluated immediately and
replaced by its result. If any operand is unknown (a function parameter,
an IO result, etc.) the expression is left as <em>residual code</em> for
the C back-end to emit.</p>
<pre class="milang"><code>-- Fully reduced at compile time:
x = 6 * 7              -- becomes: x = 42
f a = a * 2
y = f 21                -- becomes: y = 42

-- Stays as residual code (parameter unknown):
double a = a * 2        -- emitted as a C function
</code></pre>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__scc-dependency-analysis">SCC
dependency analysis</h3>
<p>Bindings are sorted into <em>strongly connected components</em> so
that each group is reduced in dependency order. Mutually-recursive
bindings land in the same SCC and are handled together.</p>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__depth-limited-recursion">Depth-limited
recursion</h3>
<p>Recursive functions are unrolled only when every argument is
concrete, and reduction is capped at a fixed depth (128 steps). This
prevents the compiler from looping on unbounded recursion while still
collapsing finite recursive computations at compile time.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__zero-cost-abstractions">Zero-cost
abstractions</h2>
<p>Because the reducer runs before code generation, any abstraction that
is fully known at compile time disappears entirely from the output:</p>
<pre class="milang"><code>-- Configuration record — reduced away at compile time
config = {width = 800; height = 600}
pixels = config.width * config.height
</code></pre>
<pre><code>config =  {width = 800, height = 600}
pixels = 480000
</code></pre>
<p>The binding <code>pixels</code> is reduced to the integer
<code>480000</code> before any C code is generated. No record
allocation, no field lookup — just a constant.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__inspecting-the-reducer-output">Inspecting
the reducer output</h2>
<p>milang ships two commands for inspecting what the compiler sees:</p>
<div class="sourceCode" id="cb289"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> dump file.mi      <span class="at">--</span> parsed AST <span class="er">(</span><span class="ex">before</span> reduction<span class="kw">)</span></span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> reduce file.mi    <span class="at">--</span> AST after partial evaluation <span class="er">(</span><span class="ex">what</span> codegen sees<span class="kw">)</span></span></code></pre></div>
<p>Comparing the two on the same file shows exactly which expressions
were collapsed and which remain as residual code. This is the primary
tool for understanding compile-time behaviour.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__partial-eval.md__what-stays-as-residual-code">What
stays as residual code</h2>
<p>Anything that depends on a value unknown at compile time is left for
the C back-end:</p>
<pre class="milang"><code>main world =
  line = world.io.readLine    -- runtime IO — cannot reduce
  world.io.println line       -- emitted as C call
</code></pre>
<p>Function parameters, IO results, and any expression transitively
depending on them are residual. Everything else is reduced.</p>
<!-- Sized types and partial evaluation

When the reducer encounters expressions involving sized numeric types the
following notes explain the current behaviour and constraints:

- The width argument to `Int'`, `UInt'`, or `Float'` must be a compile-time
  constant. The reducer requires concrete `n` values to reason about types;
  expressions like `Int' (4 * 8)` will reduce to `Int' 32` when the arithmetic
  inside the type expression is concrete.

- Type aliases such as `Int = Int' 64` are treated as syntactic sugar and are
  resolved during reduction; they do not remain at runtime.

- Current implementation note: sized types are primarily type-level and used
  for ABI/representation and annotation. The reducer evaluates constant
  arithmetic using Milang's general numeric semantics and does not automatically
  wrap or clamp values to a narrower machine width. If strict fixed-width
  arithmetic is required, use explicit conversion primitives or the C FFI,
  which maps milang sized types to fixed-width C types.

- Future work may include full width-aware reduction (clamping/wrapping at
  reduction time) and richer type-level computation.

-->
<h1 data-number="22" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__thunks--laziness"><span class="header-section-number">22</span> Thunks &amp; Laziness</h1>
<p>Milang is <strong>eager by default</strong> — every expression is
evaluated as soon as it is bound. The tilde operator <code>~</code> lets
you opt into delayed evaluation where you need it.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__creating-thunks-with-">Creating
thunks with <code>~</code></h2>
<p>Prefixing an expression with <code>~</code> wraps it in a
<em>thunk</em>: a suspended computation that is not executed until its
value is actually needed.</p>
<pre class="milang"><code>eager = 1 + 2       -- evaluated immediately
delayed = ~(1 + 2)  -- wrapped in a thunk; not yet evaluated
result = delayed     -- forced here: evaluates to 3
</code></pre>
<pre><code>eager = 3
delayed = 3
result = 3
</code></pre>
<p>When a thunk is used in a context that needs its value (passed to an
operator, printed, pattern-matched, etc.) it is <em>forced</em>
automatically — you never call a thunk explicitly.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__if-and-auto-quote-parameters"><code>if</code>
and auto-quote parameters</h2>
<p>In earlier versions of milang, <code>if</code> required explicit
thunks on both branches to prevent eager evaluation:</p>
<pre class="milang"><code>-- Old style (still works, but no longer necessary):
result = if (x &gt; 5) (x * 2) (x * 3)
</code></pre>
<p>The <code>if</code> conditional quotes its branches implicitly; write
conditionals like this:</p>
<pre class="milang"><code>x = 10
result = if (x &gt; 5) (x * 2) (x * 3)
</code></pre>
<pre><code>x = 10
result = 20
</code></pre>
<p>Both styles work — if you pass a thunk to an auto-quote parameter,
the thunk is forced after splicing. See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__metaprogramming">Metaprogramming</a>
chapter for details on <code>#</code>-params.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__nested-conditionals">Nested
conditionals</h2>
<p>Conditionals compose naturally:</p>
<pre class="milang"><code>z = 7
result = if (z &gt; 10) 100 (if (z &gt; 5) 50 0)
</code></pre>
<pre><code>z = 7
result = 50
</code></pre>
<p>Each inner <code>if</code> is only evaluated when its enclosing
branch is selected.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__lazy-bindings-with-">Lazy
bindings with <code>:=</code></h2>
<p>The <code>:=</code> operator creates a <em>lazy binding</em> —
syntactic sugar for a thunk that caches its result after the first
force:</p>
<pre class="milang"><code>x = 3
y := x + 10   -- not evaluated until y is used
z = y * 2     -- forces y here; y becomes 13, z becomes 26
</code></pre>
<pre><code>x = 3
y = &lt;closure&gt;
z = 26
</code></pre>
<p>Lazy bindings are useful for expensive computations that may never be
needed, or for establishing declaration-order dependencies without
paying upfront cost.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__thunks.md__when-to-use-thunks">When
to use thunks</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Situation</th>
<th>Mechanism</th>
</tr>
</thead>
<tbody>
<tr>
<td>Conditional branches (<code>if</code>)</td>
<td>Auto-quoted branch parameters handle this</td>
</tr>
<tr>
<td>Short-circuit logic (<code>&amp;&amp;</code>, <code>||</code>)</td>
<td>Auto-quote params handle the lazy operand</td>
</tr>
<tr>
<td>Deferred expensive work</td>
<td>Lazy binding <code>:=</code></td>
</tr>
<tr>
<td>Controlling IO ordering</td>
<td>Thunks delay side effects until forced</td>
</tr>
</tbody>
</table>
<p>The general rule: reach for <code>~</code> whenever you need to
<strong>control when</strong> an expression is evaluated rather than
relying on milang&#39;s default left-to-right eager order.</p>
<h1 data-number="23" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__metaprogramming"><span class="header-section-number">23</span> Metaprogramming</h1>
<p>Milang provides two complementary operators for working with syntax
at compile time: <strong>quote</strong> (<code>#</code>) captures an
expression as a data structure, and <strong>splice</strong>
(<code>$</code>) evaluates a data structure back into code. Combined
with partial evaluation these give you compile-time code generation
without a separate macro system.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__quote-expr">Quote:
<code>#expr</code></h2>
<p>The <code>#</code> operator captures the <em>abstract syntax
tree</em> of its operand as a tagged record. The expression is
<strong>not</strong> evaluated — only its structure is recorded.</p>
<pre class="milang"><code>q_int = #42
q_op  = #(1 + 2)
</code></pre>
<pre><code>q_int = Int {val = 42}
q_op = Op {op = +, left = Int {val = 1}, right = Int {val = 2}}
</code></pre>
<p>Each syntactic form maps to a specific record <code>tag</code>:</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Quoted form</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>#42</code></td>
<td><code>Int {val = 42}</code></td>
</tr>
<tr>
<td><code>#&quot;hello&quot;</code></td>
<td><code>Str {val = &quot;hello&quot;}</code></td>
</tr>
<tr>
<td><code>#x</code></td>
<td><code>Var {name = &quot;x&quot;}</code></td>
</tr>
<tr>
<td><code>#(f x)</code></td>
<td><code>App {fn = Var {name = &quot;f&quot;}; arg = Var {name = &quot;x&quot;}}</code></td>
</tr>
<tr>
<td><code>#(a + b)</code></td>
<td><code>Op {op = &quot;+&quot;; left = ...; right = ...}</code></td>
</tr>
<tr>
<td><code>#(\x -&gt; x)</code></td>
<td><code>Fn {param = &quot;x&quot;; body = ...}</code></td>
</tr>
</tbody>
</table>
<p>Because quoted ASTs are ordinary records you can inspect their
<code>fields</code>, pass them to functions, and build new ASTs by
constructing records directly.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__splice-expr">Splice:
<code>$expr</code></h2>
<p>The <code>$</code> operator takes a record that represents an AST
node and evaluates it as code:</p>
<pre class="milang"><code>ast = #(1 + 2)
result = $ast
</code></pre>
<pre><code>ast = Op {op = +, left = Int {val = 1}, right = Int {val = 2}}
result = 3
</code></pre>
<p>Splicing a quoted literal round-trips back to its value. More
usefully, you can build AST records by hand and splice them:</p>
<pre class="milang"><code>ast = Op {op = &quot;*&quot;; left = Int {val = 6}; right = Int {val = 7}}
answer = $ast
</code></pre>
<pre><code>ast = Op {op = *, left = Int {val = 6}, right = Int {val = 7}}
answer = 42
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__writing-macros">Writing
macros</h2>
<p>A macro in milang is just a function that takes and returns AST
records. Because the partial evaluator runs at compile time, macro
expansion happens before code generation — there is no runtime cost.</p>
<pre class="milang"><code>-- Macro: double an expression (x + x)
double_ast expr = Op {op = &quot;+&quot;; left = expr; right = expr}
r1 = $(double_ast #5)

-- Macro: negate (0 - x)
negate_ast expr = Op {op = &quot;-&quot;; left = Int {val = 0}; right = expr}
r2 = $(negate_ast #42)
</code></pre>
<pre><code>double_ast = &lt;closure&gt;
r1 = 10
negate_ast = &lt;closure&gt;
r2 = -42
</code></pre>
<p>Macros compose — you can pass one macro&#39;s output as another&#39;s
input:</p>
<pre class="milang"><code>double_ast expr = Op {op = &quot;+&quot;; left = expr; right = expr}
negate_ast expr = Op {op = &quot;-&quot;; left = Int {val = 0}; right = expr}
r = $(double_ast (negate_ast #7))
</code></pre>
<pre><code>double_ast = &lt;closure&gt;
negate_ast = &lt;closure&gt;
r = -14
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__pattern-matching-on-asts">Pattern
matching on ASTs</h2>
<p>Because quoted expressions are records, you can pattern-match on them
to transform code structurally:</p>
<pre class="milang"><code>-- Swap the arguments of a binary operator
swap_op ast = ast -&gt;
  Op {op = op; left = l; right = r} = Op {op = op; left = r; right = l}
  _ = ast
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__auto-quote-parameters-param">Auto-Quote
Parameters (<code>#param</code>)</h2>
<p>When defining a function (or binding), prefixing a parameter name
with <code>#</code> tells the compiler to <strong>automatically
quote</strong> the corresponding argument at the call site. Inside the
body, <code>$param</code> splices the captured AST back into code and
evaluates it. The caller writes ordinary expressions — no sigils
needed.</p>
<pre class="milang"><code>-- &#39;if&#39; is defined in the prelude using auto-quote params:
--   if cond #t #e = (truthy cond) -&gt; 0 = $e; _ = $t
-- The caller just writes:
x = 10
result = if (x &gt; 5) (x * 2) (x * 3)
</code></pre>
<pre><code>x = 10
result = 20
</code></pre>
<p>Because the <code>#t</code> and <code>#e</code> parameters auto-quote
their arguments, neither branch is evaluated until the matching
<code>$t</code> or <code>$e</code> splice runs. This is how milang
achieves lazy branching without keywords or special forms —
<code>if</code> is an ordinary user-defined function.</p>
<p>Auto-quote parameters work with any function, not just
<code>if</code>:</p>
<pre class="milang"><code>-- A logging wrapper that only evaluates its message when enabled
log_if enabled #msg world = if enabled (world.io.println $msg) 0
</code></pre>
<p>Note that <code>world</code> must be threaded through explicitly:
<code>world.io.println</code> requires the <code>world</code> value to
be in scope, so any function calling IO must accept it as a
parameter.</p>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__how-it-works">How
it works</h3>
<ol>
<li>The function definition declares <code>#param</code> — the
<code>#</code> is part of the parameter name in the source but is
stripped for binding purposes.</li>
<li>At each call site, the compiler wraps the corresponding argument in
<code>#(...)</code>, producing a quoted AST record.</li>
<li>In the body, <code>$param</code> splices the record back into an
expression and evaluates it in the current environment.</li>
<li>If the spliced expression contains a thunk (<code>~expr</code>), the
thunk is automatically forced after splicing — so old-style
<code>~</code> code remains backward-compatible.</li>
</ol>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__relation-to-thunks">Relation
to thunks</h3>
<p>Auto-quote parameters are strictly more general than thunks
(<code>~</code>). A thunk delays evaluation of a single expression; a
quoted parameter captures the full AST, which can be inspected,
transformed, or conditionally evaluated. For simple conditional laziness
(like <code>if</code>), the effect is the same — but auto-quote opens
the door to user-defined control flow, macros that inspect their
arguments, and other metaprogramming patterns.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__metaprogramming.md__inspection-commands">Inspection
commands</h2>
<p>Two CLI commands help you understand what the compiler sees:</p>
<div class="sourceCode" id="cb314"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> dump file.mi      <span class="at">--</span> show the parsed AST <span class="er">(</span><span class="ex">before</span> reduction<span class="kw">)</span></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> reduce file.mi    <span class="at">--</span> show the AST after partial evaluation</span></code></pre></div>
<p>Use <code>dump</code> to verify that quoting produces the record
structure you expect, and <code>reduce</code> to confirm that your
macros expand correctly at compile time.</p>
<h1 data-number="24" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__user-defined-operators"><span class="header-section-number">24</span> User-Defined Operators</h1>
<p>In milang operators are ordinary functions whose names are made of
operator characters
(<code>+ - * / ^ &lt; &gt; = ! &amp; | @ % ? :</code>). You define, use,
and pass them around exactly like any other function.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__defining-an-operator">Defining
an operator</h2>
<p>Wrap the operator name in parentheses and define it as a normal
function:</p>
<pre class="milang"><code>(&lt;=&gt;) a b = if (a == b) 0 (if (a &gt; b) 1 (0 - 1))
cmp1 = 5 &lt;=&gt; 3
cmp2 = 3 &lt;=&gt; 3
cmp3 = 1 &lt;=&gt; 5
</code></pre>
<pre><code>&lt;=&gt; = &lt;closure&gt;
cmp1 = 1
cmp2 = 0
cmp3 = -1
</code></pre>
<p>The definition <code>(&lt;=&gt;) a b = ...</code> creates a
two-argument function. You then use it infix without parentheses:
<code>5 &lt;=&gt; 3</code>.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__setting-precedence-and-associativity">Setting
precedence and associativity</h2>
<p>By default a user-defined operator gets a low precedence. Use a
<strong>parse declaration</strong> (<code>:!</code>) to set the
precedence level and associativity. The declaration must appear before
the operator&#39;s first infix use:</p>
<pre class="milang"><code>(&lt;+&gt;) :! {prec = 6; assoc = Left}
(&lt;+&gt;) a b = {x = a.x + b.x; y = a.y + b.y}

result = {x=1;y=2} &lt;+&gt; {x=3;y=4}
</code></pre>
<ul>
<li><code>prec</code> — an integer; higher binds tighter (e.g.
<code>*</code> is 7, <code>+</code> is 6).</li>
<li><code>assoc</code> — <code>Left</code> or <code>Right</code>;
controls grouping of chained uses.</li>
</ul>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__operators-as-first-class-values">Operators
as first-class values</h2>
<p>Wrapping a built-in or user-defined operator in parentheses gives you
a function value you can pass to higher-order functions:</p>
<pre class="milang"><code>add = (+)
result = add 3 4
</code></pre>
<pre><code>add = &lt;closure&gt;
result = 7
</code></pre>
<p>This is especially useful with folds and maps:</p>
<pre class="milang"><code>total = fold (+) 0 [1, 2, 3, 4, 5]
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__functions-as-infix-operators">Functions
as infix operators</h2>
<p>The backtick syntax lets you use any two-argument function in infix
position:</p>
<pre class="milang"><code>div a b = a / b
result = 10 `div` 2
</code></pre>
<pre><code>div = &lt;closure&gt;
result = 5
</code></pre>
<p><code>a `f` b</code> is equivalent to <code>f a b</code>. This works
with any function, not just operator-named ones.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__user-operators.md__prefix-vs-infix">Prefix
vs. infix</h2>
<p>Every operator can be used both ways:</p>
<pre class="milang"><code>-- Infix (the usual way)
r1 = 5 &lt;=&gt; 3

-- Prefix (wrap in parens)
r2 = (&lt;=&gt;) 5 3
</code></pre>
<p>Both forms are interchangeable. Prefix is handy when you want to
partially apply an operator or pass it as an argument.</p>
<h1 data-number="25" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__security.md__security--capabilities"><span class="header-section-number">25</span> Security &amp; Capabilities</h1>
<p>Milang&#39;s security model is <strong>structural</strong>: if a function
does not receive a capability, it physically cannot use it. There is no
global mutable state, no ambient authority, and no
<code>unsafePerformIO</code> escape hatch.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__security.md__capability-based-io">Capability-based
IO</h2>
<p>All side effects flow through the <code>world</code> record that the
runtime passes to <code>main</code>. The record contains sub-records —
<code>world.io</code>, <code>world.process</code>, etc. — each granting
access to a specific class of operations.</p>
<p>You restrict a function&#39;s power by passing only the sub-record it
needs:</p>
<pre class="milang"><code>-- greet can print but cannot access the filesystem or exec processes
greet io = io.println &quot;hello&quot;

main world = greet world.io
</code></pre>
<p>Because <code>greet</code> receives <code>world.io</code> and nothing
else, it is structurally impossible for it to read files, spawn
processes, or access environment variables. This is milang&#39;s equivalent
of the principle of least privilege — enforced by the language, not by
convention.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__security.md__remote-import-pinning">Remote
import pinning</h2>
<p>Milang supports importing modules by URL. To prevent supply-chain
attacks every remote import must be <em>pinned</em> to a SHA-256 content
hash:</p>
<div class="sourceCode" id="cb325"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a><span class="ex">milang</span> pin file.mi</span></code></pre></div>
<p>This command scans <code>file.mi</code> for URL imports, fetches each
one, computes its hash, and records the result. On subsequent
compilations the compiler verifies that the fetched content matches the
pinned hash and refuses to proceed if it does not.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__security.md__c-ffi-security">C
FFI security</h2>
<p>Milang can call C functions via its FFI. Native C code operates
outside the capability model, so FFI is the one place where the
structural guarantee can be bypassed. Two CLI flags are described to let
you lock this down (note: these flags are not currently implemented in
the core compiler):</p>
<ul>
<li><strong><code>--no-ffi</code></strong> — disallow all C FFI imports.
The program may only use pure milang and the built-in <code>world</code>
capabilities.</li>
<li><strong><code>--no-remote-ffi</code></strong> — allow C FFI in local
<code>.mi</code> files but forbid it in any module imported by URL (and
any module transitively imported from that URL module). This lets you
trust your own native code while sandboxing third-party libraries.</li>
</ul>
<p>Trust is transitive: if your local file imports a remote module
<code>A</code>, and <code>A</code> imports a relative module
<code>B</code>, then <code>B</code> is also in the remote trust zone and
subject to <code>--no-remote-ffi</code>.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__language__security.md__structural-security-summary">Structural
security summary</h2>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Layer</th>
<th>Mechanism</th>
</tr>
</thead>
<tbody>
<tr>
<td>Function-level isolation</td>
<td>Pass minimal <code>world</code> sub-records</td>
</tr>
<tr>
<td>Supply-chain integrity</td>
<td><code>milang pin</code> + SHA-256 verification</td>
</tr>
<tr>
<td>Native code gating</td>
<td><code>--no-ffi</code>, <code>--no-remote-ffi</code></td>
</tr>
<tr>
<td>Purity tracking</td>
<td>Compiler tracks <code>world</code>-tainted expressions; pure code
cannot perform IO</td>
</tr>
</tbody>
</table>
<p>The design principle is simple: the only way to perform a side effect
is to hold the right capability, and capabilities can only travel
through explicit function arguments. The FFI gating flags close the one
remaining loophole by controlling access to native C code.</p>
<h1 data-number="26" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__tooling.md__tooling--build-notes"><span class="header-section-number">26</span> Tooling &amp; Build Notes</h1>
<p>This page collects practical tips for building Milang programs and
the documentation.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__tooling.md__running-examples-and-the-cli">Running
examples and the CLI</h2>
<ul>
<li>Use the local <code>./milang</code> binary in the repository root
for running and experimenting with <code>.mi</code> files; if you
installed <code>milang</code> on your PATH you can omit
<code>./</code>.</li>
<li>Useful commands:
<ul>
<li><code>./milang run file.mi</code> — compile and run</li>
<li><code>./milang compile file.mi output.c</code> — emit standalone
C</li>
<li><code>./milang dump file.mi</code> — show parsed AST (before
reduction)</li>
<li><code>./milang reduce file.mi</code> — show partially-evaluated AST
(what the codegen sees)</li>
<li><code>./milang repl</code> — interactive REPL</li>
</ul></li>
</ul>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__tooling.md__c-toolchain">C
toolchain</h2>
<p>Milang emits C and requires a working C toolchain (gcc or clang). On
Debian/Ubuntu:</p>
<div class="sourceCode" id="cb326"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> apt-get install build-essential pkg-config</span></code></pre></div>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__tooling.md__building-the-docs-mdbook">Building
the docs (mdBook)</h2>
<p>The repo includes an <code>mdbook</code>-style source under
<code>docs/src</code> and a small preprocessor
<code>docs/mdbook-milang.py</code> that executes code blocks tagged
<code>milang,run</code> and appends their output. Two ways to build:</p>
<ul>
<li>If the project has a <code>Makefile</code>, run
<code>make docs</code> (required if available).</li>
<li>Or, install mdBook and run:</li>
</ul>
<div class="sourceCode" id="cb327"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a><span class="ex">mdbook</span> build docs/src <span class="at">-d</span> docs/out</span></code></pre></div>
<p>Ensure your mdBook configuration registers the
<code>mdbook-milang.py</code> preprocessor, or run the script manually
when verifying examples.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__tooling.md__common-issues--debugging">Common
issues &amp; debugging</h2>
<ul>
<li>Parsing ambiguity with inline record literals: when passing a record
literal directly as an argument, parenthesize it or bind it to a name,
e.g. <code>getField ({a = 1}) &quot;a&quot;</code> or
<code>r = {a = 1} getField r &quot;a&quot;</code>.</li>
<li><code>toInt</code> / <code>toFloat</code> return
<code>Nothing</code> on parse failure — check results with pattern
matching on <code>Just</code> / <code>Nothing</code>.</li>
<li><code>charAt</code> and <code>getField</code> return
<code>Nothing</code> when out-of-bounds or missing.</li>
<li>Division/modulo by zero is handled at the runtime/C level
(implementation-defined); avoid relying on undefined behaviour in
portable code.</li>
<li>Use <code>milang dump</code> to inspect how the parser grouped
expressions if you hit unexpected parse errors.</li>
</ul>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__tooling.md__quick-checklist">Quick
checklist</h2>
<ul>
<li><code>./milang dump</code> to verify parser grouping</li>
<li><code>./milang reduce</code> to verify partial evaluation</li>
<li><code>mdbook build</code> (or <code>make docs</code>) to render the
site</li>
</ul>
<h1 data-number="27" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__repl"><span class="header-section-number">27</span> REPL</h1>
<p>The milang REPL (Read-Eval-Print Loop) lets you evaluate expressions
and define bindings interactively.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__starting-the-repl">Starting
the REPL</h2>
<div class="sourceCode" id="cb328"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> repl</span></code></pre></div>
<p>You&#39;ll see a <code>λ&gt;</code> prompt. Type any expression and press
Enter to evaluate it:</p>
<pre class="text"><code>λ&gt; 2 + 3
5
λ&gt; &quot;hello&quot; + &quot; &quot; + &quot;world&quot;
&quot;hello world&quot;
</code></pre>
<p>Type <code>:q</code> or press <strong>Ctrl-D</strong> to exit.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__defining-bindings">Defining
Bindings</h2>
<p>Bindings persist across inputs, so you can build up definitions
incrementally:</p>
<pre class="text"><code>λ&gt; double x = x * 2
double = (\x -&gt; (x * 2))
λ&gt; double 21
42
λ&gt; quadruple x = double (double x)
quadruple = (\x -&gt; (double (double x)))
λ&gt; quadruple 5
20
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__single-line-input">Single-line
Input</h2>
<p>The REPL reads one line at a time. Each binding must fit on a single
line. Use semicolons to separate alternatives within a
<code>-&gt;</code> pattern match:</p>
<pre class="text"><code>λ&gt; area s = s -&gt; Circle = 3.14 * s.radius * s.radius; Rect = s.width * s.height
</code></pre>
<p>Multi-line indented definitions must be written in a <code>.mi</code>
file and loaded via <code>milang run</code>.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__prelude-functions">Prelude
Functions</h2>
<p>All standard prelude functions are available immediately — no imports
needed:</p>
<pre class="text"><code>λ&gt; map (\x = x * x) [1, 2, 3, 4, 5]
Cons {head = 1, tail = Cons {head = 4, tail = ...}}
λ&gt; filter (\x = x &gt; 3) [1, 2, 3, 4, 5]
Cons {head = 4, tail = Cons {head = 5, tail = Nil {}}}
λ&gt; fold (\acc x = acc + x) 0 [1, 2, 3]
6
λ&gt; len [10, 20, 30]
3
</code></pre>
<blockquote>
<p><strong>Note:</strong> Lists are displayed as raw
<code>Cons</code>/<code>Nil</code> record expressions — the REPL shows
the partially-evaluated AST, not a pretty-printed representation.</p>
</blockquote>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__type-annotations">Type
Annotations</h2>
<p>You can add type annotations to bindings:</p>
<pre class="text"><code>λ&gt; x :: Int
λ&gt; x = 42
x = 42
</code></pre>
<p>The type is associated with the binding and checked when the value is
defined.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__viewing-bindings">Viewing
Bindings</h2>
<p>Use <code>:env</code> to show all user-defined bindings (prelude
bindings are hidden):</p>
<pre class="text"><code>λ&gt; double x = x * 2
double = (\x -&gt; (x * 2))
λ&gt; :env
double = (\x -&gt; (x * 2))
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__how-it-works">How
It Works</h2>
<p>Each REPL input is:</p>
<ol>
<li>Parsed as either a binding (namespace) or a bare expression</li>
<li>Reduced using the same partial evaluator as
<code>milang reduce</code></li>
<li>The reduced form is printed</li>
</ol>
<p>New bindings extend the accumulated environment for all subsequent
inputs. This is a <strong>pure partial evaluator</strong> — there is no
C compilation or gcc invocation in the REPL. Residuals (expressions that
cannot be further reduced) are printed as-is.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__limitations">Limitations</h2>
<ul>
<li><strong>No IO</strong> — the REPL evaluates pure expressions only.
There is no <code>world</code> value available, so
<code>world.io.println</code> and similar IO operations cannot be
used.</li>
<li><strong>No imports</strong> — <code>import</code> declarations are
not supported in the REPL.</li>
<li><strong>No multi-line input</strong> — each input must fit on a
single line. Write multi-line programs in <code>.mi</code> files.</li>
<li><strong>No command history</strong> — the up/down arrow keys do not
recall previous inputs.</li>
<li><strong>Raw list output</strong> — lists are printed as
<code>Cons</code>/<code>Nil</code> record expressions, not
<code>[1, 2, 3]</code>.</li>
</ul>
<p>For IO and imports, write a <code>.mi</code> file and use
<code>milang run</code> instead.</p>
<h1 data-number="28" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__compiler-modes"><span class="header-section-number">28</span> Compiler Modes</h1>
<p>The <code>milang</code> binary supports six commands. Each operates
on a <code>.mi</code> source file and exercises different parts of the
compilation pipeline.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__milang-run"><code>milang run</code></h2>
<div class="sourceCode" id="cb335"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> run file.mi</span></code></pre></div>
<p>The most common command. It parses the file, resolves imports,
partially evaluates, generates C, compiles with <code>gcc -O2</code>,
runs the resulting binary, and cleans up temporary files.</p>
<p>If the file defines <code>main world = ...</code>, the program runs
as a normal executable and <code>main</code>&#39;s return value becomes the
process exit code. If there is no <code>main</code> binding with a
parameter, milang runs in <strong>script mode</strong> (see below).</p>
<h3 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__example">Example</h3>
<pre class="milang"><code>main world =
  world.io.println &quot;running!&quot;
</code></pre>
<pre><code>running!
</code></pre>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__milang-compile"><code>milang compile</code></h2>
<div class="sourceCode" id="cb338"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> compile file.mi            <span class="co"># writes file.c</span></span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> compile file.mi output.c   <span class="co"># writes output.c</span></span>
<span id="cb338-3"><a href="#cb338-3" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> compile file.mi <span class="at">-</span>          <span class="co"># prints C to stdout</span></span></code></pre></div>
<p>Emits a self-contained C source file. The milang runtime is embedded
in the output, so the generated file has no external dependencies beyond
the standard C library.</p>
<p>Compile it yourself:</p>
<div class="sourceCode" id="cb339"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a><span class="fu">gcc</span> output.c <span class="at">-o</span> program</span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true" tabindex="-1"></a><span class="ex">./program</span></span></code></pre></div>
<p>This is useful when you want to inspect the generated code,
cross-compile, or integrate milang output into a larger C project.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__milang-dump"><code>milang dump</code></h2>
<div class="sourceCode" id="cb340"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> dump file.mi</span></code></pre></div>
<p>Prints the <strong>parsed AST</strong> before import resolution or
partial evaluation. This shows you exactly how the parser interpreted
your source, including all five annotation domains (<code>=</code>,
<code>::</code>, <code>:~</code>, <code>:?</code>, <code>:!</code>).</p>
<p>Use this to debug syntax issues — if the parser grouped your
expressions differently than you expected, <code>dump</code> will show
it.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__milang-reduce"><code>milang reduce</code></h2>
<div class="sourceCode" id="cb341"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> reduce file.mi</span></code></pre></div>
<p>Prints the AST <strong>after partial evaluation</strong>. This is
what the code generator actually sees. Any expression that could be
computed at compile time has been reduced to a literal value.</p>
<p>Use this to verify that the partial evaluator is doing what you
expect:</p>
<pre class="milang"><code>square x = x * 2
answer = square 21
</code></pre>
<pre><code>square = &lt;closure&gt;
answer = 42
</code></pre>
<p>Running <code>milang reduce</code> on this file would show
<code>answer = 42</code> — the function call was evaluated at compile
time.</p>
<p>If you need to see reduction without the prelude injected, use
<code>milang raw-reduce file.mi</code> to view the reduced AST for the
file alone.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__milang-pin"><code>milang pin</code></h2>
<div class="sourceCode" id="cb344"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> pin file.mi</span></code></pre></div>
<p>Finds all URL imports in the file, fetches them, computes a Merkle
hash (SHA-256 of the content plus all transitive sub-imports), and
rewrites the source file to include the hash:</p>
<p>Before:</p>
<pre class="milang"><code>utils = import &quot;https://example.com/utils.mi&quot;
</code></pre>
<p>After:</p>
<pre class="milang"><code>utils = import&#39; &quot;https://example.com/utils.mi&quot; ({sha256 = &quot;a1b2c3...&quot;})
</code></pre>
<p>This ensures that the imported code hasn&#39;t changed since you
<code>last</code> pinned it. If the content changes, the compiler will
report a hash mismatch and refuse to proceed.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__milang-repl"><code>milang repl</code></h2>
<div class="sourceCode" id="cb347"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./milang</span> repl</span></code></pre></div>
<p>Starts an interactive REPL where you can evaluate expressions and
define bindings. See the <a href="#home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__repl.md__repl">REPL</a>
chapter for details.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__script-mode">Script
Mode</h2>
<p>When a <code>.mi</code> file has no <code>main</code> binding that
takes a parameter, <code>milang run</code> operates in <strong>script
mode</strong>: it evaluates every top-level binding and prints each
name-value pair.</p>
<pre class="milang"><code>a = 2 + 3
b = a * a
greeting = &quot;hello&quot;
</code></pre>
<pre><code>a = 5
b = 25
greeting = hello
</code></pre>
<p>Script mode is ideal for quick calculations and testing small
snippets. Prelude definitions are automatically hidden from the
output.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__security-flags">Security
Flags</h2>
<p>Milang supports flags to restrict what imported code can do (note:
these flags are not currently implemented in the core compiler; see
.github/ROADMAP.md):</p>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr>
<th>Flag</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--no-ffi</code></td>
<td>Disables all C FFI imports (no <code>.h</code> files can be
imported)</td>
</tr>
<tr>
<td><code>--no-remote-ffi</code></td>
<td>Disallows C FFI for remote (URL) imports specifically</td>
</tr>
</tbody>
</table>
<p>These flags are useful when running untrusted code. A URL import
might try to <code>import &quot;/usr/include/stdlib.h&quot;</code> and call
arbitrary C functions — <code>--no-remote-ffi</code> prevents this while
still allowing your own local FFI usage.</p>
<h2 class="unnumbered unlisted" id="home__matthew__dev__milang-copilot__docs-out__pandoc__single__src__guides__compiler-modes.md__summary">Summary</h2>
<table>
<thead>
<tr>
<th>Command</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>run file.mi</code></td>
<td>Compile and execute</td>
</tr>
<tr>
<td><code>compile file.mi [out.c]</code></td>
<td>Emit standalone C</td>
</tr>
<tr>
<td><code>dump file.mi</code></td>
<td>Show parsed AST</td>
</tr>
<tr>
<td><code>reduce file.mi</code></td>
<td>Show partially-evaluated AST</td>
</tr>
<tr>
<td><code>pin file.mi</code></td>
<td>Fetch URL imports, write SHA-256 hashes</td>
</tr>
<tr>
<td><code>repl</code></td>
<td>Interactive evaluation</td>
</tr>
</tbody>
</table>
</body>
</html>
