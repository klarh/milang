[Header 1 ("metaprogramming", [], []) [Str "Metaprogramming"], Para [Str "Milang provides two complementary operators for working with syntax at compile", SoftBreak, Str "time: ", Strong [Str "quote"], Str " (", Code ("", [], []) "#", Str ") captures an expression as a data structure, and ", Strong [Str "splice"], SoftBreak, Str "(", Code ("", [], []) "$", Str ") evaluates a data structure back into code. Combined with partial", SoftBreak, Str "evaluation these give you compile-time code generation without a separate macro", SoftBreak, Str "system."], Header 2 ("quote-expr", ["unnumbered", "unlisted"], []) [Str "Quote: ", Code ("", [], []) "#expr"], Para [Str "The ", Code ("", [], []) "#", Str " operator captures the ", Emph [Str "abstract syntax tree"], Str " of its operand as a tagged", SoftBreak, Str "record. The expression is ", Strong [Str "not"], Str " evaluated — only its structure is recorded."], CodeBlock ("", ["milang"], []) "q_int = #42
q_op  = #(1 + 2)
", CodeBlock ("", [""], []) "q_int = Int {val = 42}
q_op = Op {op = +, left = Int {val = 1}, right = Int {val = 2}}
", Para [Str "Each syntactic form maps to a specific record ", Code ("", [], []) "tag", Str ":"], Table ("", [], []) (Caption Nothing []) [(AlignDefault, ColWidthDefault), (AlignDefault, ColWidthDefault)] (TableHead ("", [], []) [Row ("", [], []) [Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Str "Syntax"]], Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Str "Quoted form"]]]]) [(TableBody ("", [], []) (RowHeadColumns 0) [] [Row ("", [], []) [Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "#42"]], Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "Int {val = 42}"]]], Row ("", [], []) [Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "#\"hello\""]], Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "Str {val = \"hello\"}"]]], Row ("", [], []) [Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "#x"]], Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "Var {name = \"x\"}"]]], Row ("", [], []) [Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "#(f x)"]], Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "App {fn = Var {name = \"f\"}; arg = Var {name = \"x\"}}"]]], Row ("", [], []) [Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "#(a + b)"]], Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "Op {op = \"+\"; left = ...; right = ...}"]]], Row ("", [], []) [Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "#(\\x -> x)"]], Cell ("", [], []) AlignDefault (RowSpan 0) (ColSpan 0) [Plain [Code ("", [], []) "Fn {param = \"x\"; body = ...}"]]]])] (TableFoot ("", [], []) []), Para [Str "Because quoted ASTs are ordinary records you can inspect their ", Code ("", [], []) "fields", Str ", pass them", SoftBreak, Str "to functions, and build new ASTs by constructing records directly."], Header 2 ("splice-expr", ["unnumbered", "unlisted"], []) [Str "Splice: ", Code ("", [], []) "$expr"], Para [Str "The ", Code ("", [], []) "$", Str " operator takes a record that represents an AST node and evaluates it as", SoftBreak, Str "code:"], CodeBlock ("", ["milang"], []) "ast = #(1 + 2)
result = $ast
", CodeBlock ("", [""], []) "ast = Op {op = +, left = Int {val = 1}, right = Int {val = 2}}
result = 3
", Para [Str "Splicing a quoted literal round-trips back to its value. More usefully, you can", SoftBreak, Str "build AST records by hand and splice them:"], CodeBlock ("", ["milang"], []) "ast = Op {op = \"*\"; left = Int {val = 6}; right = Int {val = 7}}
answer = $ast
", CodeBlock ("", [""], []) "ast = Op {op = *, left = Int {val = 6}, right = Int {val = 7}}
answer = 42
", Header 2 ("writing-macros", ["unnumbered", "unlisted"], []) [Str "Writing macros"], Para [Str "A macro in milang is just a function that takes and returns AST records. Because", SoftBreak, Str "the partial evaluator runs at compile time, macro expansion happens before code", SoftBreak, Str "generation — there is no runtime cost."], CodeBlock ("", ["milang"], []) "-- Macro: double an expression (x + x)
double_ast expr = Op {op = \"+\"; left = expr; right = expr}
r1 = $(double_ast #5)

-- Macro: negate (0 - x)
negate_ast expr = Op {op = \"-\"; left = Int {val = 0}; right = expr}
r2 = $(negate_ast #42)
", CodeBlock ("", [""], []) "double_ast = <closure>
r1 = 10
negate_ast = <closure>
r2 = -42
", Para [Str "Macros compose — you can pass one macro's output as another's input:"], CodeBlock ("", ["milang"], []) "double_ast expr = Op {op = \"+\"; left = expr; right = expr}
negate_ast expr = Op {op = \"-\"; left = Int {val = 0}; right = expr}
r = $(double_ast (negate_ast #7))
", CodeBlock ("", [""], []) "double_ast = <closure>
negate_ast = <closure>
r = -14
", Header 2 ("pattern-matching-on-asts", ["unnumbered", "unlisted"], []) [Str "Pattern matching on ASTs"], Para [Str "Because quoted expressions are records, you can pattern-match on them to", SoftBreak, Str "transform code structurally:"], CodeBlock ("", ["milang"], []) "-- Swap the arguments of a binary operator
swap_op ast = ast ->
  Op {op = op; left = l; right = r} = Op {op = op; left = r; right = l}
  _ = ast
", Header 2 ("auto-quote-parameters-param", ["unnumbered", "unlisted"], []) [Str "Auto-Quote Parameters (", Code ("", [], []) "#param", Str ")"], Para [Str "When defining a function (or binding), prefixing a parameter name with ", Code ("", [], []) "#", SoftBreak, Str "tells the compiler to ", Strong [Str "automatically quote"], Str " the corresponding argument at the", SoftBreak, Str "call site. Inside the body, ", Code ("", [], []) "$param", Str " splices the captured AST back into code", SoftBreak, Str "and evaluates it. The caller writes ordinary expressions — no sigils needed."], CodeBlock ("", ["milang"], []) "-- 'if' is defined in the prelude using auto-quote params:
--   if cond #t #e = (truthy cond) -> 0 = $e; _ = $t
-- The caller just writes:
x = 10
result = if (x > 5) (x * 2) (x * 3)
", CodeBlock ("", [""], []) "x = 10
result = 20
", Para [Str "Because the ", Code ("", [], []) "#t", Str " and ", Code ("", [], []) "#e", Str " parameters auto-quote their arguments, neither", SoftBreak, Str "branch is evaluated until the matching ", Code ("", [], []) "$t", Str " or ", Code ("", [], []) "$e", Str " splice runs. This is how", SoftBreak, Str "milang achieves lazy branching without keywords or special forms — ", Code ("", [], []) "if", Str " is an", SoftBreak, Str "ordinary user-defined function."], Para [Str "Auto-quote parameters work with any function, not just ", Code ("", [], []) "if", Str ":"], CodeBlock ("", ["milang"], []) "-- A logging wrapper that only evaluates its message when enabled
log_if enabled #msg world = if enabled (world.io.println $msg) 0
", Para [Str "Note that ", Code ("", [], []) "world", Str " must be threaded through explicitly: ", Code ("", [], []) "world.io.println", Str " requires the ", Code ("", [], []) "world", Str " value to be in scope, so any function calling IO must accept it as a parameter."], Header 3 ("how-it-works", ["unnumbered", "unlisted"], []) [Str "How it works"], OrderedList (1, DefaultStyle, DefaultDelim) [[Plain [Str "The function definition declares ", Code ("", [], []) "#param", Str " — the ", Code ("", [], []) "#", Str " is part of the parameter", SoftBreak, Str "name in the source but is stripped for binding purposes."]], [Plain [Str "At each call site, the compiler wraps the corresponding argument in ", Code ("", [], []) "#(...)", Str ",", SoftBreak, Str "producing a quoted AST record."]], [Plain [Str "In the body, ", Code ("", [], []) "$param", Str " splices the record back into an expression and", SoftBreak, Str "evaluates it in the current environment."]], [Plain [Str "If the spliced expression contains a thunk (", Code ("", [], []) "~expr", Str "), the thunk is", SoftBreak, Str "automatically forced after splicing — so old-style ", Code ("", [], []) "~", Str " code remains", SoftBreak, Str "backward-compatible."]]], Header 3 ("relation-to-thunks", ["unnumbered", "unlisted"], []) [Str "Relation to thunks"], Para [Str "Auto-quote parameters are strictly more general than thunks (", Code ("", [], []) "~", Str "). A thunk", SoftBreak, Str "delays evaluation of a single expression; a quoted parameter captures the full", SoftBreak, Str "AST, which can be inspected, transformed, or conditionally evaluated. For", SoftBreak, Str "simple conditional laziness (like ", Code ("", [], []) "if", Str "), the effect is the same — but", SoftBreak, Str "auto-quote opens the door to user-defined control flow, macros that inspect", SoftBreak, Str "their arguments, and other metaprogramming patterns."], Header 2 ("inspection-commands", ["unnumbered", "unlisted"], []) [Str "Inspection commands"], Para [Str "Two CLI commands help you understand what the compiler sees:"], CodeBlock ("", ["bash"], []) "milang dump file.mi      -- show the parsed AST (before reduction)
milang reduce file.mi    -- show the AST after partial evaluation
", Para [Str "Use ", Code ("", [], []) "dump", Str " to verify that quoting produces the record structure you expect, and", SoftBreak, Code ("", [], []) "reduce", Str " to confirm that your macros expand correctly at compile time."]]