{-# LANGUAGE OverloadedStrings #-}
module Core.Prelude (preludeBindings) where

import Data.Text (Text)
import qualified Data.Text as T
import Core.Syntax
import Core.Parser (parseProgram)

-- | The milang prelude as source text. Parsed at compiler startup.
-- | Bootstrap prelude â€” strict evaluation only (no #/$ quote/splice yet).
preludeSrc :: Text
preludeSrc = T.unlines
  [ "Bool = {True; False}"
  , "List = {Nil; Cons head tail}"
  , "Maybe = {Nothing; Just val}"
  , "eq a b = a -> _ = a == b"
  , "if cond #t #e = (truthy cond) -> 0 = $e; _ = $t"
  , "truthy val = val -> False = 0; Nil = 0; Nothing = 0; 0 = 0; \"\" = 0; _ = 1"
  , "toString val = val -> True = \"True\"; False = \"False\"; Nil = \"[]\"; Nothing = \"Nothing\"; Just x = \"Just(\" + toString x + \")\"; _ = _toString val"
  , "fromMaybe def m = m -> Just x = x; Nothing = def"
  , "id x = x"
  , "const x y = x"
  , "flip f a b = f b a"
  , "null lst = lst -> Nil = 1; _ = 0"
  , "len lst = lst -> Nil = 0; Cons h t = 1 + len t"
  , "head lst = lst -> Nil = Nothing; Cons h t = Just h"
  , "tail lst = lst -> Nil = Nothing; Cons h t = Just t"
  , "fold f acc lst = lst -> Nil = acc; Cons h t = fold f (f acc h) t"
  , "map f lst = lst -> Nil = []; Cons h t = Cons (f h) (map f t)"
  , "filter f lst = lst -> Nil = []; Cons h t = if (f h) (Cons h (filter f t)) (filter f t)"
  , "concat a b = a -> Nil = b; Cons h t = Cons h (concat t b)"
  , "push lst x = concat lst [x]"
  , "at lst i = lst -> Nil = Nothing; Cons h t = if (i == 0) (Just h) (at t (i - 1))"
  , "at' i lst = at lst i"
  , "sum lst = fold (\\acc x -> acc + x) 0 lst"
  , "product lst = fold (\\acc x -> acc * x) 1 lst"
  , "any f lst = fold (\\acc x -> if (f x) 1 acc) 0 lst"
  , "all f lst = fold (\\acc x -> if (f x) acc 0) 1 lst"
  , "contains lst x = any (\\el -> el == x) lst"
  , "range start end = range_helper start end []"
  , "range_helper start end acc = if (start >= end) acc (range_helper start (end - 1) (Cons (end - 1) acc))"
  , "zip a b = if (null a) [] (if (null b) [] (Cons [a.head, b.head] (zip a.tail b.tail)))"
  , "last lst = lst -> Nil = Nothing; Cons h t = if (null t) (Just h) (last t)"
  , "init lst = lst -> Nil = Nothing; Cons h t = if (null t) (Just []) (Just (Cons h (fromMaybe [] (init t))))"
  , "reverse lst = fold (\\acc x -> Cons x acc) [] lst"
  , "take n lst = if (n == 0) [] (take_inner n lst)"
  , "take_inner n lst = lst -> Nil = []; Cons h t = Cons h (take (n - 1) t)"
  , "drop n lst = if (n == 0) lst (drop_inner n lst)"
  , "drop_inner n lst = lst -> Nil = []; Cons h t = drop (n - 1) t"
  , "enumerate lst = zip (range 0 (len lst)) lst"
  , "join sep lst = lst -> Nil = \"\"; Cons h t = if (null t) h (h + sep + join sep t)"
  , "abs x = if (x < 0) (0 - x) x"
  , "neg x = 0 - x"
  , "min a b = if (a < b) a b"
  , "max a b = if (a > b) a b"
  , "not x = if x 0 1"
  , "(|>) x f = f x"
  , "(>>) f g x = g (f x)"
  , "(<<) f g x = f (g x)"
  , "(&&) a #b = if a ($b) 0"
  , "(||) a #b = if a 1 ($b)"
  -- Type aliases
  , "Int = Int' 64"
  , "UInt = UInt' 64"
  , "Float = Float' 64"
  , "Byte = UInt' 8"
  -- Trait annotations
  , "console :~ [console]"
  , "io :~ [console]"
  , "fs :~ [fs.read, fs.write]"
  , "process :~ [process]"
  , "env :~ [env]"
  -- IO function trait annotations (so rebound names keep effect tracking)
  , "println :~ [console]"
  , "print :~ [console]"
  , "readLine :~ [console]"
  -- Math type annotations
  , "float :: Int : Float"
  , "round :: Float : Int"
  , "floor :: Float : Int"
  , "ceil :: Float : Int"
  -- Type annotations for prelude functions
  , "toString :: a : Str"
  , "fromMaybe :: a : Maybe : a"
  , "eq :: a : a : Num"
  , "truthy :: a : Num"
  , "id :: a : a"
  , "const :: a : b : a"
  , "flip :: (a : b : c) : b : a : c"
  , "null :: List : Num"
  , "len :: a : Num"
  , "head :: List : Maybe"
  , "tail :: List : Maybe"
  , "fold :: (a : b : a) : a : List : a"
  , "map :: (a : b) : List : List"
  , "filter :: (a : Num) : List : List"
  , "concat :: List : List : List"
  , "push :: List : a : List"
  , "at :: List : Num : Maybe"
  , "at' :: Num : List : Maybe"
  , "sum :: List : Num"
  , "product :: List : Num"
  , "any :: (a : Num) : List : Num"
  , "all :: (a : Num) : List : Num"
  , "contains :: List : a : Num"
  , "range :: Num : Num : List"
  , "zip :: List : List : List"
  , "last :: List : Maybe"
  , "init :: List : Maybe"
  , "reverse :: List : List"
  , "take :: Num : List : List"
  , "drop :: Num : List : List"
  , "enumerate :: List : List"
  , "join :: Str : List : Str"
  , "abs :: a : a"
  , "neg :: Num : Num"
  , "min :: a : a : a"
  , "max :: a : a : a"
  , "not :: a : Num"
  -- IO function types
  , "println :: a : Num"
  , "print :: a : Num"
  -- Operator types
  , "(+) :: a : a : a"
  , "(-) :: a : a : a"
  , "(*) :: a : a : a"
  , "(/) :: a : a : a"
  , "(%) :: Int : Int : Int"
  , "(**) :: a : Int : a"
  , "(==) :: a : a : Int"
  , "(/=) :: a : a : Int"
  , "(<) :: a : a : Int"
  , "(>) :: a : a : Int"
  , "(<=) :: a : a : Int"
  , "(>=) :: a : a : Int"
  , "(|>) :: a : (a : b) : b"
  , "(>>) :: (a : b) : (b : c) : a : c"
  , "(<<) :: (b : c) : (a : b) : a : c"
  , "(&&) :: a : a : Num"
  , "(||) :: a : a : Num"
  -- Boosted prelude
  , "flatMap f lst = fold (\\acc x -> concat acc (f x)) [] lst"
  , "foldRight f z lst = lst -> Nil = z; Cons h t = f h (foldRight f z t)"
  , "scanLeft f acc lst = Cons acc (scanLeft_tail f acc lst)"
  , "scanLeft_tail f acc lst = lst -> Nil = []; Cons h t = scanLeft f (f acc h) t"
  , "unfold f seed = unfold_step f (f seed)"
  , "unfold_step f result = result -> Nothing = []; Just pair = Cons pair.fst (unfold f pair.snd)"
  , "partition_step pred acc x = if (pred x) (partition_yes acc x) (partition_no acc x)"
  , "partition_yes acc x = {yes = Cons x acc.yes; no = acc.no}"
  , "partition_no acc x = {yes = acc.yes; no = Cons x acc.no}"
  , "partition pred lst = fold (partition_step pred) {yes = []; no = []} lst"
  , "iterate f x = Cons x ~(iterate f (f x))"
  , "curry f a b = f {fst = a; snd = b}"
  , "uncurry f pair = f pair.fst pair.snd"
  , "on f g a b = f (g a) (g b)"
  , "maybe def f m = m -> Nothing = def; Just x = f x"
  , "fst pair = pair.fst"
  , "snd pair = pair.snd"
  , "sortBy cmp lst = lst -> Nil = []; Cons pivot rest = concat (concat (sortBy cmp (filter (\\x -> cmp x pivot < 0) rest)) [pivot]) (sortBy cmp (filter (\\x -> cmp x pivot >= 0) rest))"
  , "sort lst = sortBy (\\a b -> if (a < b) (0 - 1) (if (a == b) 0 1)) lst"
  , "nubBy eq lst = lst -> Nil = []; Cons h t = Cons h (nubBy eq (filter (\\x -> not (eq h x)) t))"
  , "nub lst = nubBy (\\a b -> a == b) lst"
  , "groupBy eq lst = lst -> Nil = []; Cons h t = Cons (Cons h (filter (\\x -> eq h x) t)) (groupBy eq (filter (\\x -> not (eq h x)) t))"
  -- Boosted prelude type annotations
  , "flatMap :: (a : List) : List : List"
  , "foldRight :: (a : b : b) : b : List : b"
  , "scanLeft :: (a : b : a) : a : List : List"
  , "iterate :: (a : a) : a : List"
  , "maybe :: b : (a : b) : Maybe : b"
  , "sortBy :: (a : a : Num) : List : List"
  , "sort :: List : List"
  , "nubBy :: (a : a : Num) : List : List"
  , "nub :: List : List"
  , "groupBy :: (a : a : Num) : List : List"
  -- String utilities
  , "startsWith str prefix = slice str 0 (len prefix) == prefix"
  , "endsWith str suffix = slice str (len str - len suffix) (len str) == suffix"
  , "words str = split str \" \""
  , "lines str = split str \"\\n\""
  , "unwords lst = join \" \" lst"
  , "unlines lst = join \"\\n\" lst"
  -- String utility type annotations
  , "startsWith :: Str : Str : Num"
  , "endsWith :: Str : Str : Num"
  , "words :: Str : List"
  , "lines :: Str : List"
  , "unwords :: List : Str"
  , "unlines :: List : Str"
  ]

-- | Parse the prelude source into bindings.
preludeBindings :: [Binding]
preludeBindings = case parseProgram "<prelude>" preludeSrc of
  Right (Namespace bs) -> bs
  Right _  -> error "prelude did not parse as Namespace"
  Left err -> error $ "prelude parse error: " ++ show err
